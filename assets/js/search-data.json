{
  
    
        "post0": {
            "title": "Connecting Jupyter to EC2",
            "content": "Intro . The goal of this is to run a jupyter notebook as if it were locally but have all of it running in the backend. I have tried sagemaker and other packaged products, and I prefer just using Jupyter-lab. This guide is how I connect. . This is mostly a reference guide to refer back to until you memorize the steps. If this is your first time using AWS, EC2, or you aren&#39;t already fairly familiar with the process then I recommend checking out a guide that explains things a bit more. This is meant to be be a good place to use as a reminder of what to do while you do it the first 10 or 20 times, rather than a step-by-step guide on how to do it. . A great place (and what I used initially) for getting instructions to do this for the first time would be: https://fzr72725.github.io/2018/01/14/How-to-Connect-to-Jupyter-Notebook-Server-on-AWS-EC2-from-Your-Local-Machine.html . Launch an EC2 Instance . First, launch an EC2 instance. I use p2.xlarge for almost everything. You will be prompted to create or use an existing key pair. You will need this private key, so download it and store it somewhere. If you lose it, you lose the EC2 instance. I have a copy of mine in S3 . Connect to your EC2 Instance . In the AWS console, you can click connect. If your EC2 instance isn&#39;t started then start it. It will give you instructions for SSHing in. There&#39;s 2 steps that are important here. . chmod 400 &lt;key.pem&gt; . and . ssh -i &quot;key.pem&quot; username@whatever_it_tells_you_in_aws_console.compute-1.amazonaws.com . Launch Jupyter . In the EC2 I just ssh into I run . jupyter-lab --no-browser --port=8889 . I stored my key in the directory ~/.aws, but that should be replaced with wherever. I open a new console and run . ssh -i ~/.aws/key.pem -L 8000:localhost:8889 username@whatever_it_tells_you_in_aws_console.compute-1.amazonaws.com . From there open localhost:8000 in your browser and you are good to go. If it asks for a token you can find it in the terminal output where you ran jupyter-lab! .",
            "url": "https://isaac-flath.github.io/blog/aws/2020/06/25/JupyterEC2.html",
            "relUrl": "/aws/2020/06/25/JupyterEC2.html",
            "date": " • Jun 25, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fine Grain Image Classification",
            "content": "Intro . In this blog we are going to do an image classification to take dog pictures and predict the breed. This is considered &#39;fine grain&#39; because the difference between classes is fairly minimal. Classifying between breeds of dogs is fine grain, classifying whether something is a dog or a cup is not. . To do this we are going to use fastaiv2, which is the new version of fastai that will come out in July. . Setup . Library Import and Dataset Download . from fastai2.vision.all import * seed = 42 # Download and get path for dataseet path = untar_data(URLs.PETS) #Sample dataset from fastai2 path.ls() . (#2) [Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/images&#39;),Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/annotations&#39;)] . img = (path/&#39;images&#39;).ls()[0] img . Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/images/British_Shorthair_154.jpg&#39;) . Data Setup . Data Blocks and data loaders are convenient ways that fastai helps us manage an load data. There is a lot going on in DataBlock so I am going to break it down piece by piece. . DataBlock . Blocks: What is our data? x is our images (ImageBlock) and y is our categories (CategoryBlock). In this case each image will get a dog breed as the category. . | get_items: How do we get our data (x)? We use the predefined get_image_files for this, though we can give it something custom if needed. . | splitter: How should we create the validation set? The splitter splits our data into test and validation sets. The default 20% validation set is just fine, but we define a seed so it is reproducable. . | get_y: How do we get our dependent variable (y)? In this care we are going to get it from the file name. With using_attr, we can apply a function to an attribute of the file (name). So here we are using regex on the file name to get y. . | item_tfms: What transformations do we need to do before packing things up to be sent to the GPU? In this case resizing it to 460. . | batch_tfms: What transformations do we want to do in batches on the GPU? There are many default transforms, and we are specifying a few ourselves (min_scale and size). . | . pets = DataBlock( blocks = (ImageBlock, CategoryBlock), get_items = get_image_files, splitter= RandomSplitter(valid_pct = 0.2, seed=seed), get_y= using_attr(RegexLabeller(r&#39;(.+)_ d+.jpg$&#39;),&#39;name&#39;), item_tfms=Resize(460), batch_tfms=aug_transforms(min_scale = 0.9,size=224) ) . dataloader . The dataloader is what we will actually interact with. In the DataBlock we defined lots of things we need to do to get and transform images, but not where to get them from. We define that in the dataloade . dls = pets.dataloaders(path/&quot;images&quot;) . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . dls.show_batch() . Training the Model . Get a basic model working . In 2 lines of code I am going to create and train a basic model. There&#39;s a couple things to note: . I am using the dls from the previous step. This is where we defined how to load the data, how to label it, data augmentation, training/validation split, etc. | I can also pass standard architectures. &quot;Resnet&quot; is a common architecture for image classification. &quot;34&quot; signifies that it has 34 layers. If you wish to understand what a layer is, please check out the Image Classifier Basics blog posts that build a simple 1 layer net. | I set a metric, but use the default loss metric. . Note: Loss is what the model uses to train on. Error rate is just for our reference. Accuracy and error rates make very poor choices for loss function because they have either 0 or infinite slope, so calculating the gradient/path value/derivative is not meaningful. This is a prime example of why good functions for computers to understand what&#8217;s going on and good functions for peope to understand what&#8217;s going on can be very different things. | learn = cnn_learner(dls, resnet34, metrics=error_rate) . Next we are going to fine tune the model. . If we were starting from scratch when training a model we will train every layer. Fine tuning is about training the final layer(s) and leaving the rest intact. Previous layers were set using weights via transfer learning. What this means is that a model was trained to be able to detect and classify a bunch of different objects. The earlier layers of the neural network detect things that are common to lots of images (ie circles, edges, corners, etc.). These don&#39;t need to change much generally. The last layer is predicting the specific thing, in our case pet breeds. This is what we need to change. . Note: A fun thought expirament on understanding why transfer learning works is to think about elements that you need to identify basically everything that you take for granted, and try to imagininng the world and objects around you if you were missing some basic concepts. For example, what if you did not have the ability to tell the diference vs a surface and and edge? Or what if you couldn&#8217;t tell the difference between something that is straight and curved? Or what if circular shaped, square shaped objects, and traingular shaped objects all looked the same to you? What if you could not recognize any pattern - what would you think of a tile floor if you had no ability to comprehend that the tiles are a pattern? How could you function if you couldn&#8217;t see corners? . learn.fine_tune(3) . epoch train_loss valid_loss error_rate time . 0 | 1.506214 | 0.332651 | 0.112314 | 01:04 | . epoch train_loss valid_loss error_rate time . 0 | 0.479490 | 0.239846 | 0.073748 | 01:21 | . learn.recorder.plot_loss() . We see out validation loss improves significantly with our error rate. We will use this error rate at our baseline. . Note: A common misconception is when training loss is lower than validation loss. This is not the case. You cannot be overfitting as unless your validation scores get worse. In a well tuned model, training loss will almost always be lower than validation loss. Let&#39;s take a look at our model, then see if we can improve it! . Look at results . First lets look at some pictures. I think it&#39;s always good to actually loook at some prediciton the model is making. . learn.show_results() . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . Next, we will take a look at some more specif data. Let&#39;s start with a high level confusion matrix. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(12,12), dpi=60) . interp.plot_top_losses(9, figsize=(15,10)) . interp.most_confused(min_val=3) . [(&#39;staffordshire_bull_terrier&#39;, &#39;american_pit_bull_terrier&#39;, 8), (&#39;Bengal&#39;, &#39;Abyssinian&#39;, 5), (&#39;Egyptian_Mau&#39;, &#39;Bengal&#39;, 5), (&#39;beagle&#39;, &#39;basset_hound&#39;, 5), (&#39;Ragdoll&#39;, &#39;Birman&#39;, 4), (&#39;american_pit_bull_terrier&#39;, &#39;american_bulldog&#39;, 4), (&#39;Maine_Coon&#39;, &#39;Bengal&#39;, 3), (&#39;american_bulldog&#39;, &#39;staffordshire_bull_terrier&#39;, 3), (&#39;great_pyrenees&#39;, &#39;samoyed&#39;, 3), (&#39;miniature_pinscher&#39;, &#39;chihuahua&#39;, 3)] . Make a Better Model . Now that we have a baseline using the defaults, let&#39;s see what we can do to improve it. We will talk about a few main topics. . Freezing and Unfreezing for training | Learning Rate Finder | Discriminate learning rrate | Architecture | . Learning Rate Finder . The Learning Rate Finder is very important because setting a good learning rate can make or break a model. We will use it multiple times, and it will come up in essentially every deep learning project. It is good to spend some time to understand what it is showing and expirament. . The learning rate finder (lr_find) gives us 3 things: . lr_min: This is the learning rate that gives us the minimum loss in our graph. 1 common rule of thumb is to divide this by 10 and use that as your learning rate. | lr_steep: This is the steepest point on our graph. Another rule of thumb is to make this your learning rate. Interestingly enough, these 2 rules of thumb often end up with very similar results. | graph: The graph is really what i use when determining a learning rate. At the beginning of the graph we see very little reduction in loss. At the end of the graph we see loss spiking. Obviously neight of those are good. In reality we want our learning rate to be somewhere in the middle-ish of that steep decline. This is in line with our 2 rule of thumbs. | . learn = cnn_learner(dls, resnet34, metrics=error_rate) lr_min,lr_steep = learn.lr_find() . print(f&quot;Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}&quot;) . Minimum/10: 1.00e-02, steepest point: 3.63e-03 . Now that we have our graph, let&#39;s train our model with this learning rate. . What&#39;s the difference between fine tune and fit one cycle? . learn.fit_one_cycle(3, 3e-3) . epoch train_loss valid_loss error_rate time . 0 | 1.153070 | 0.330983 | 0.110961 | 01:02 | . 1 | 0.529226 | 0.247058 | 0.083221 | 01:03 | . 2 | 0.313324 | 0.211899 | 0.071042 | 01:02 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . Unfreezing . Unfreezing a model is about training the full model. We spoke earlier about fine_tune only training that last layers. This is a great start and we want to train the last layers more than the early layers, but we still want to train the early layers. Unfreeze allows us to do this. Now that we unfroze the model and are going to train the model more, we will need to do our learning rate finder to pick a good learning rate again. . learn.unfreeze() learn.lr_find() . SuggestedLRs(lr_min=2.2908675418875645e-07, lr_steep=6.309573450380412e-07) . Discriminative Learning Rates . Discriminative Learning Rates means that we are going to use a different learning rate for each layer. We have previously really been training the final layers of the model. We are now ready to udate all the weights and biases, including the ones that were set by our transfer learning. While we do want to train the whole model, we don&#39;t want to train it at the same speed. We want more changes in the end (ie figuring out exactly which breed it is) and less changes in the early layers (ie identifying lines). . We will fit this now for 12 epochs. The first layers will have 1e-6 learning rate. The final layers will have 1e-4. Middle layers will be between those 2 numbers. . learn.fit_one_cycle(12, lr_max=slice(1e-6,1e-4)) . epoch train_loss valid_loss error_rate time . 0 | 0.268549 | 0.212036 | 0.070365 | 01:20 | . 1 | 0.251425 | 0.203802 | 0.070365 | 01:21 | . 2 | 0.225780 | 0.199052 | 0.069012 | 01:20 | . 3 | 0.208234 | 0.200992 | 0.068336 | 01:20 | . 4 | 0.194438 | 0.196424 | 0.066306 | 01:20 | . 5 | 0.157829 | 0.192350 | 0.064276 | 01:20 | . 6 | 0.143234 | 0.184955 | 0.062246 | 01:20 | . 7 | 0.142764 | 0.182605 | 0.061570 | 01:20 | . 8 | 0.128651 | 0.177451 | 0.060217 | 01:21 | . 9 | 0.122703 | 0.181155 | 0.060893 | 01:20 | . 10 | 0.122970 | 0.180962 | 0.061570 | 01:20 | . 11 | 0.118004 | 0.179349 | 0.056834 | 01:20 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . learn.recorder.plot_loss() . Make an even better model . The general process for creating a good model is to overfit, then reduce overfitting. Overfitting is defined as continuing to train increases your validation loss. Once you do that, you run through these steps to reduce overfitting: . Get more data if you can | Do more meaningful data augmentations if you can | Regularization (ie dropout) | Model Architecture | . Let&#39;s start by overfitting a model. I am going to move to a larger architecture as it was proving extremely difficult to overfit with a resnet 34. A larger architecture has a larger capacity for accuracy, but a larger capacity to overfit. . from fastai2.callback.fp16 import * learn = cnn_learner(dls, resnet50, metrics=error_rate).to_fp16() learn.fine_tune(6, freeze_epochs=3) . epoch train_loss valid_loss error_rate time . 0 | 1.361485 | 0.268512 | 0.091340 | 01:47 | . 1 | 0.581800 | 0.271851 | 0.092693 | 01:43 | . 2 | 0.418578 | 0.246892 | 0.075101 | 01:43 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . epoch train_loss valid_loss error_rate time . 0 | 0.272392 | 0.259666 | 0.079838 | 02:17 | . 1 | 0.288575 | 0.263761 | 0.081867 | 02:15 | . 2 | 0.248105 | 0.289011 | 0.080514 | 02:15 | . 3 | 0.153504 | 0.207065 | 0.061570 | 02:15 | . 4 | 0.084501 | 0.177351 | 0.049391 | 02:15 | . 5 | 0.058676 | 0.167289 | 0.047361 | 02:15 | . learn.recorder.plot_loss() . learn = cnn_learner(dls, resnet101, metrics=error_rate).to_fp16() learn.fine_tune(6, freeze_epochs=3) . epoch train_loss valid_loss error_rate time . 0 | 1.288229 | 0.233059 | 0.064276 | 02:34 | . 1 | 0.574160 | 0.257547 | 0.074425 | 02:35 | . 2 | 0.386964 | 0.234290 | 0.069689 | 02:35 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . epoch train_loss valid_loss error_rate time . 0 | 0.254327 | 0.228201 | 0.066982 | 03:28 | . 1 | 0.316892 | 0.411258 | 0.111637 | 03:28 | . 2 | 0.268326 | 0.331656 | 0.088633 | 03:28 | . 3 | 0.154121 | 0.218441 | 0.058863 | 03:28 | . 4 | 0.088543 | 0.182722 | 0.048038 | 03:29 | . 5 | 0.047005 | 0.175852 | 0.045332 | 03:30 | . learn.recorder.plot_loss() .",
            "url": "https://isaac-flath.github.io/blog/neural%20networks/image%20classification/2020/06/25/Fine-Grain-Image-Classifier1.html",
            "relUrl": "/neural%20networks/image%20classification/2020/06/25/Fine-Grain-Image-Classifier1.html",
            "date": " • Jun 25, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fine Grain Image Classification",
            "content": "Intro . In this blog we are going to do an image classification to take dog pictures and predict the breed. This is considered &#39;fine grain&#39; because the difference between classes is fairly minimal. Classifying between breeds of dogs is fine grain, classifying whether something is a dog or a cup is not. . To do this we are going to use fastaiv2, which is the new version of fastai that will come out in July. The purpose of this post is to introduce a few key concepts that will be useful as we move into harder problems . Setup . Library Import and Dataset Download . from fastai2.vision.all import * seed = 42 # Download and get path for dataseet path = untar_data(URLs.PETS) #Sample dataset from fastai2 path.ls() . (#2) [Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/images&#39;),Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/annotations&#39;)] . img = (path/&#39;images&#39;).ls()[0] img . Path(&#39;/home/ubuntu/.fastai/data/oxford-iiit-pet/images/British_Shorthair_154.jpg&#39;) . Data Setup . Data Blocks and data loaders are convenient ways that fastai helps us manage an load data. There is a lot going on in DataBlock so I am going to break it down piece by piece. . DataBlock . Blocks: What is our data? x is our images (ImageBlock) and y is our categories (CategoryBlock). In this case each image will get a dog breed as the category. . | get_items: How do we get our data (x)? We use the predefined get_image_files for this, though we can give it something custom if needed. . | splitter: How should we create the validation set? The splitter splits our data into test and validation sets. The default 20% validation set is just fine, but we define a seed so it is reproducable. . | get_y: How do we get our dependent variable (y)? In this care we are going to get it from the file name. With using_attr, we can apply a function to an attribute of the file (name). So here we are using regex on the file name to get y. . | item_tfms: What transformations do we need to do before packing things up to be sent to the GPU? In this case resizing it to 460. . | batch_tfms: What transformations do we want to do in batches on the GPU? There are many default transforms, and we are specifying a few ourselves (min_scale and size). . | . pets = DataBlock( blocks = (ImageBlock, CategoryBlock), get_items = get_image_files, splitter= RandomSplitter(valid_pct = 0.2, seed=seed), get_y= using_attr(RegexLabeller(r&#39;(.+)_ d+.jpg$&#39;),&#39;name&#39;), item_tfms=Resize(460), batch_tfms=aug_transforms(min_scale = 0.9,size=224) ) . dataloader . The dataloader is what we will actually interact with. In the DataBlock we defined lots of things we need to do to get and transform images, but not where to get them from. We define that in the dataloade . dls = pets.dataloaders(path/&quot;images&quot;) . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . dls.show_batch() . Training the Model . Get a basic model working . In 2 lines of code I am going to create and train a basic model. There&#39;s a couple things to note: . I am using the dls from the previous step. This is where we defined how to load the data, how to label it, data augmentation, training/validation split, etc. | I can also pass standard architectures. &quot;Resnet&quot; is a common architecture for image classification. &quot;34&quot; signifies that it has 34 layers. If you wish to understand what a layer is, please check out the Image Classifier Basics blog posts that build a simple 1 layer net. | I set a metric, but use the default loss metric. . Note: Loss is what the model uses to train on. Error rate is just for our reference. Accuracy and error rates make very poor choices for loss function because they have either 0 or infinite slope, so calculating the gradient/path value/derivative is not meaningful. This is a prime example of why good functions for computers to understand what&#8217;s going on and good functions for peope to understand what&#8217;s going on can be very different things. | learn = cnn_learner(dls, resnet34, metrics=error_rate) . Next we are going to fine tune the model. . If we were starting from scratch when training a model we will train every layer. Fine tuning is about training the final layer(s) and leaving the rest intact. Previous layers were set using weights via transfer learning. What this means is that a model was trained to be able to detect and classify a bunch of different objects. The earlier layers of the neural network detect things that are common to lots of images (ie circles, edges, corners, etc.). These don&#39;t need to change much generally. The last layer is predicting the specific thing, in our case pet breeds. This is what we need to change. . Note: A fun thought expirament on understanding why transfer learning works is to think about elements that you need to identify basically everything that you take for granted, and try to imagininng the world and objects around you if you were missing some basic concepts. For example, what if you did not have the ability to tell the diference vs a surface and and edge? Or what if you couldn&#8217;t tell the difference between something that is straight and curved? Or what if circular shaped, square shaped objects, and traingular shaped objects all looked the same to you? What if you could not recognize any pattern - what would you think of a tile floor if you had no ability to comprehend that the tiles are a pattern? How could you function if you couldn&#8217;t see corners? . learn.fine_tune(3) . epoch train_loss valid_loss error_rate time . 0 | 1.519997 | 0.311546 | 0.106901 | 01:05 | . epoch train_loss valid_loss error_rate time . 0 | 0.472248 | 0.341488 | 0.105548 | 01:23 | . 1 | 0.374747 | 0.241689 | 0.076455 | 01:22 | . 2 | 0.230108 | 0.202105 | 0.066306 | 01:22 | . learn.recorder.plot_loss() . We see out validation loss improves significantly with our error rate. We will use this error rate at our baseline. . Note: A common misconception is when training loss is lower than validation loss. This is not the case. You cannot be overfitting as unless your validation scores get worse. In a well tuned model, training loss will almost always be lower than validation loss. Let&#39;s take a look at our model, then see if we can improve it! . Look at results . First lets look at some pictures. I think it&#39;s always good to actually loook at some prediciton the model is making. . learn.show_results() . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . Many times in classification we look at a confusion matrix. As you can see, when we start having a lot of classes, it is really hard to make anything meaningful out of the confusion matrix. There&#39;s just too many classes. . Next, we will take a look at some more specif data. Let&#39;s start with a high level confusion matrix. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(12,12), dpi=60) . Instead, we look at top losses to see where our model was most wrong. We also look at the &#39;most confused&#39; function whichprints which classes it gets confused on most often. . interp.plot_top_losses(9, figsize=(15,10)) . interp.most_confused(min_val=3) . [(&#39;staffordshire_bull_terrier&#39;, &#39;american_pit_bull_terrier&#39;, 5), (&#39;British_Shorthair&#39;, &#39;Russian_Blue&#39;, 4), (&#39;Ragdoll&#39;, &#39;Birman&#39;, 4), (&#39;beagle&#39;, &#39;basset_hound&#39;, 4), (&#39;Birman&#39;, &#39;Ragdoll&#39;, 3), (&#39;Egyptian_Mau&#39;, &#39;Bengal&#39;, 3), (&#39;american_pit_bull_terrier&#39;, &#39;american_bulldog&#39;, 3), (&#39;havanese&#39;, &#39;yorkshire_terrier&#39;, 3)] . Make a Better Model . Now that we have a baseline using the defaults, let&#39;s see what we can do to improve it. We will talk about a few main topics. . Freezing and Unfreezing for training | Learning Rate Finder | Discriminate learning rrate | Architecture | . Learning Rate Finder . The Learning Rate Finder is very important because setting a good learning rate can make or break a model. We will use it multiple times, and it will come up in essentially every deep learning project. It is good to spend some time to understand what it is showing and expirament. . The learning rate finder (lr_find) gives us 3 things: . lr_min: This is the learning rate that gives us the minimum loss in our graph. 1 common rule of thumb is to divide this by 10 and use that as your learning rate. | lr_steep: This is the steepest point on our graph. Another rule of thumb is to make this your learning rate. Interestingly enough, these 2 rules of thumb often end up with very similar results. | graph: The graph is really what i use when determining a learning rate. At the beginning of the graph we see very little reduction in loss. At the end of the graph we see loss spiking. Obviously nether of those are good. In reality we want our learning rate to be somewhere in the middle-ish of that steep decline. This is in line with our 2 rule of thumbs. | . learn = cnn_learner(dls, resnet34, metrics=error_rate) lr_min,lr_steep = learn.lr_find() . print(f&quot;Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}&quot;) . Minimum/10: 1.00e-02, steepest point: 3.63e-03 . Now that we have our graph, let&#39;s train our model with this learning rate. . What&#39;s the difference between fine tune and fit one cycle? . learn.fit_one_cycle(3, 3e-3) . epoch train_loss valid_loss error_rate time . 0 | 1.108581 | 0.351311 | 0.108931 | 01:03 | . 1 | 0.510538 | 0.250211 | 0.078484 | 01:04 | . 2 | 0.329532 | 0.207013 | 0.063599 | 01:04 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . Unfreezing . Unfreezing a model is about training the full model. We spoke earlier about fine_tune only training that last layers. This is a great start and we want to train the last layers more than the early layers, but we still want to train the early layers. Unfreeze allows us to do this. Now that we unfroze the model and are going to train the model more, we will need to do our learning rate finder to pick a good learning rate again. . learn.unfreeze() learn.lr_find() . SuggestedLRs(lr_min=1.584893179824576e-05, lr_steep=5.754399353463668e-06) . Discriminative Learning Rates . Discriminative Learning Rates means that we are going to use a different learning rate for each layer. We have previously really been training the final layers of the model. We are now ready to udate all the weights and biases, including the ones that were set by our transfer learning. While we do want to train the whole model, we don&#39;t want to train it at the same speed. We want more changes in the end (ie figuring out exactly which breed it is) and less changes in the early layers (ie identifying lines). This isn&#39;t so different than how people work. Learning a new thing (ie a type of dog breed) is much easier than improving my fundamental understanding of the world around me. . We will fit this now for 6 epochs. The first layers will have 1e-6 learning rate. The final layers will have 1e-4. Middle layers will be between those 2 numbers. We can see we get down to just under a 6% error rate. 94% accuracy - not bad! . learn.fit_one_cycle(6, lr_max=slice(1e-6,1e-4)) . epoch train_loss valid_loss error_rate time . 0 | 0.260102 | 0.199174 | 0.064953 | 01:22 | . 1 | 0.243101 | 0.191330 | 0.062246 | 01:23 | . 2 | 0.211765 | 0.187266 | 0.059540 | 01:22 | . 3 | 0.188451 | 0.184359 | 0.063599 | 01:22 | . 4 | 0.181025 | 0.180899 | 0.060217 | 01:22 | . 5 | 0.175231 | 0.181373 | 0.059540 | 01:22 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . learn.recorder.plot_loss() . Architecture . Another simple lever is to increase the number of layers in the neural network. The more layers, the higher capacity to learn from data. This also means the higher capacity that you overfit, so more layers does not always mean better! . Note: Overfitting is defined as continued training increases your validation loss. Many people feel that overfitting is when your training loss is less than validation loss, but in reality almost every well tuned model will have a lower training loss than validation loss. If the prediction accuracy on things the model haven&#8217;t seen keeps getting better, how can you be overfitting? Lets see what the impact can be from using a different architecture. A few comments: . We were using resnet34 before, and now we are using resnet101. the number represents the number of layers | We added a to_fp16. We are actually decreasing the precision of our calculations a bit for 2 reasons Faster to train | Helps combat overfitting | . | We are using fine_tune with freeze_epochs. All we are doing is training with the earlier layers frozen for 3 epochs, then training unfreezing, then training for 6 epochs. Take a look through the code of the fine_tune method at the end and you will see that I am not summarizing, that&#39;s just exactly what it is doing. (self.freeze -&gt; self.fit_one_cycle -&gt; divide learning rate -&gt; self.unfreeze -&gt; self.fit_one_cycle). | . With the resnet101 we are down to less that 5% error rate. Even better! . learn = cnn_learner(dls, resnet101, metrics=error_rate).to_fp16() learn.fine_tune(6, freeze_epochs=3) . epoch train_loss valid_loss error_rate time . 0 | 1.371693 | 0.247931 | 0.079161 | 02:43 | . 1 | 0.551731 | 0.246441 | 0.077131 | 02:39 | . 2 | 0.371089 | 0.233275 | 0.080514 | 02:39 | . /home/ubuntu/anaconda3/lib/python3.7/site-packages/torch/nn/functional.py:2854: UserWarning: The default behavior for interpolate/upsample with float scale_factor will change in 1.6.0 to align with other frameworks/libraries, and use scale_factor directly, instead of relying on the computed output size. If you wish to keep the old behavior, please set recompute_scale_factor=True. See the documentation of nn.Upsample for details. warnings.warn(&#34;The default behavior for interpolate/upsample with float scale_factor will change &#34; . epoch train_loss valid_loss error_rate time . 0 | 0.258692 | 0.246271 | 0.081191 | 03:36 | . 1 | 0.310040 | 0.321208 | 0.091340 | 03:33 | . 2 | 0.266156 | 0.289912 | 0.081867 | 03:34 | . 3 | 0.149828 | 0.213094 | 0.060893 | 03:34 | . 4 | 0.082449 | 0.183762 | 0.056834 | 03:35 | . 5 | 0.048759 | 0.173572 | 0.049391 | 03:34 | . learn.recorder.plot_loss() . ??learn.fine_tune . Signature: learn.fine_tune( epochs, base_lr=0.002, freeze_epochs=1, lr_mult=100, pct_start=0.3, div=5.0, lr_max=None, div_final=100000.0, wd=None, moms=None, cbs=None, reset_opt=False, ) Source: @patch @log_args(but_as=Learner.fit) @delegates(Learner.fit_one_cycle) def fine_tune(self:Learner, epochs, base_lr=2e-3, freeze_epochs=1, lr_mult=100, pct_start=0.3, div=5.0, **kwargs): &#34;Fine tune with `freeze` for `freeze_epochs` then with `unfreeze` from `epochs` using discriminative LR&#34; self.freeze() self.fit_one_cycle(freeze_epochs, slice(base_lr), pct_start=0.99, **kwargs) base_lr /= 2 self.unfreeze() self.fit_one_cycle(epochs, slice(base_lr/lr_mult, base_lr), pct_start=pct_start, div=div, **kwargs) File: ~/anaconda3/lib/python3.7/site-packages/fastai2/callback/schedule.py Type: method .",
            "url": "https://isaac-flath.github.io/blog/neural%20networks/image%20classification/2020/06/25/Fine-Grain-Image-Classifier.html",
            "relUrl": "/neural%20networks/image%20classification/2020/06/25/Fine-Grain-Image-Classifier.html",
            "date": " • Jun 25, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Neural Network Basics (Part 2)",
            "content": "from fastai2.vision.all import * from fastai2.data.external import * from PIL import Image import math . Intro . Today we will be working with the MNIST dataset. The goal is going to be to take an image of handwritten digits and automatically predict what number it is. We will be building a Neural Network to do this. This is building off of the Image Classifier Basics post where we classified into 3s and 7s. If anything in this post is confusing, I reccomend heading over to part 1. I am assuming that the content covered in Part 1 is understood. . If you get through this and want more detail, I highly recommend checking out Deep Learning for Coders with fastai &amp; Pytorch by Jeremy Howard and Sylvain Gugger. All of the material in this guide and more is covered in much greater detail in that book. . https://www.amazon.com/Deep-Learning-Coders-fastai-PyTorch/dp/1492045527 . Load the Data . Naturally, the first step is to get and load the data. We&#39;ll look at it a bit along tohe way to make sure it was loaded properly as well. We will be using fastai&#39;s built in dataset feature rather than sourcing it ourself. I am skimming over this quickly as this was covered in part 1. . # This command downloads the MNIST_TINY dataset and returns the path where it was downloaded path = untar_data(URLs.MNIST) # This takes that path from above, and get the path for training and validation training = [x.ls() for x in (path/&#39;training&#39;).ls().sorted()] validation = [x.ls() for x in (path/&#39;testing&#39;).ls().sorted()] . Let&#39;s take a look at an image. The first thing I reccomend doing for any dataset is to view something to verify you loaded it right. The second thing is to look at the size of it. This is not just for memory concerns, but you want to generally know some basics about whatever you are working with. . # Let&#39;s view what one of the images looks like im3 = Image.open(training[6][1]) im3 . # Let&#39;s see what shape the underlying matrix is that represents the picture tensor(im3).shape . torch.Size([28, 28]) . Linear Equation . We are looking to do wx + b = y. It seems that a Neural network should use some super fancy equation in it&#39;s layers, but that&#39;s all it is. In a single class classifier, y has 1 column as it is predicting 1 thing. In a multiclass classifier y has &quot;however-many-classes-you-have&quot; columns. . Tensor Setup . The first thing I will do is get my xs and ys in tensors in the right format. . training_t = list() for x in range(0,len(training)): # For each class, stack them together. Divide by 255 so all numbers are between 0 and 1 training_t.append(torch.stack([tensor(Image.open(i)) for i in training[x]]).float()/255) validation_t = list() for x in range(0,len(validation)): # For each class, stack them together. Divide by 255 so all numbers are between 0 and 1 validation_t.append(torch.stack([tensor(Image.open(i)) for i in validation[x]]).float()/255) . # Let&#39;s make sure images are the same size as before (ie we didn&#39;t screw anything up) training_t[1][1].shape . torch.Size([28, 28]) . Let&#39;s do a simple average of one of our images. It&#39;s a nice sanity check to see that we did things ok. We can see that after averaging, we get a recognizable number. That&#39;s a good sign. . show_image(training_t[5].mean(0)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbf7ea98290&gt; . # combine all our different images into 1 matrix. Convert Rank 3 tensor to rank 2 tensor. x = torch.cat([x for x in training_t]).view(-1, 28*28) valid_x = torch.cat([x for x in validation_t]).view(-1, 28*28) # Defining Y. I am starting with a tensor of all 0. # This tensor has 1 row per image, and 1 column per class y = tensor([[0]*len(training_t)]*len(x)) valid_y = tensor([[0]*len(validation_t)]*len(valid_x)) # Column 0 = 1 when the digit is a 0, 0 when the digit is not a 0 # Column 1 = 1 when the digit is a 1, 0 when the digit is not a 1 # Column 2 = 1 when the digit is a 2, 0 when the digit is not a 2 # etc. j=0 for colnum in range(0,len(training_t)): y[j:j+len(training_t[colnum]):,colnum] = 1 j = j + len(training[colnum]) j=0 for colnum in range(0,len(validation_t)): valid_y[j:j+len(validation_t[colnum]):,colnum] = 1 j = j + len(validation[colnum]) # Combine by xs and ys into 1 dataset for convenience. dset = list(zip(x,y)) valid_dset = list(zip(valid_x,valid_y)) # Inspect the shape of our tensors x.shape,y.shape,valid_x.shape,valid_y.shape . (torch.Size([60000, 784]), torch.Size([60000, 10]), torch.Size([10000, 784]), torch.Size([10000, 10])) . Perfect. We have exactly what we need and defined above. 60,000 images x 784 pixels for my x. A 60,000 images x 10 classes for the predictions. . 10,000 images make up the validation set. . Calculate wx + b . Let&#39;s initialize our weights and biases, then do the matrix multiplication and make sure the output is the expected shape (60,000 images x 10 classes). . # Here is how we will initialize paramaters. This is just giving me random numbers. def init_params(size, std=1.0): return (torch.randn(size)*std).requires_grad_() # Initializze w and b weight tensors w = init_params((28*28,10)) b = init_params(10) . # Lets do our linear equation and see what shape we get. (x@w+b).shape,(valid_x@w+b).shape . (torch.Size([60000, 10]), torch.Size([10000, 10])) . Great, we have the right number of predictions. Obviously the predictions are no good. There a couple things left to do. The first thing we need to do is turn our Linear Equation into a Neural Network. To do that we need to do this twice, with a ReLu inbetween. . Neural Network . . Note: You can check out the first Image Classifier blog post, which explains does this in a simpler problem (single class classifier) and assumes less pre-requisite knowledge. I am assuming that the information in Part 1 is understood. If you understand Part 1, you are ready for Part2! . # Here&#39;s a simple Neural Network. # This can have more layers by duplicating the patten seen below, this is just the fewest layers for demonstration. def simple_net(xb): # Linear Equation from above res = xb@w1 + b1 #Linear # Replace any negative values with 0. This is called a ReLu. res = res.max(tensor(0.0)) #ReLu # Do another Linear Equation res = res@w2 + b2 #Linear # return the predictions return res . # initialize random weights. # The number 30 here can be adjusted for more or less model complexity. multipliers = 30 w1 = init_params((28*28,multipliers)) b1 = init_params(multipliers) w2 = init_params((multipliers,10)) b2 = init_params(10) . simple_net(x).shape # 60,000 images with 10 predictions per class (one per digit) . torch.Size([60000, 10]) . Improving Weights and Biases . We have predictions with random weights and biases. What we need to do is to get these weights and biases to be the right numbers rather than random numbers. To do this we need to use Gradient Descent to improve the weights. Here&#39;s roughly what we need to do: . Create a loss function to measure how close (or far) off we are | Calculate the gradient (slope) so we know which direction to step | Adjust our values in that direction | Repeat many times | . The first thing we need to use gradient descent is we need a loss function. Let&#39;s use something simple, how far off we were. If the correct answer was 1, and we predicted a 0.5 that would be a loss of 0.5. We will do this for every class . The one addition is that we will add something called a sigmoid. All a sigmoid is doing is ensuring that all of our predictions land between 0 and 1. We never want to predict anything outside of these ranges. . Note: If you want more of a background on what is going on here, please take a look at my series on Gradient Descent where I dive deeper on this. We will be calculating a gradient - which are equivilant to the &quot;Path Value&quot; . Loss Function . def mnist_loss(predictions, targets): # make all prediction between 0 and 1 predictions = predictions.sigmoid() # Difference between predictions and target return torch.where(targets==1, 1-predictions, predictions).mean() . # Calculate loss on training and validation sets to make sure the function works mnist_loss(simple_net(x),y),mnist_loss(simple_net(valid_x),valid_y) . (tensor(0.5644, grad_fn=&lt;MeanBackward0&gt;), tensor(0.5678, grad_fn=&lt;MeanBackward0&gt;)) . Calculate Gradient . Now we have a function we need to optimize and a loss function to tell us our error. We are ready for gradient descent. Let&#39;s create a function to change our weights. . First, we will make sure our datasets are in a DataLoader. This is convenience class that helps manage our data and get batches. . . Note: This is the same from part 1 . # Batch size of 256 - feel free to change that based on your memory dl = DataLoader(dset, batch_size=1000, shuffle=True) valid_dl = DataLoader(valid_dset, batch_size=1000) # Example for how to get the first batch xb,yb = first(dl) valid_xb,valid_yb = first(valid_dl) . def calc_grad(xb, yb, model): # calculate predictions preds = model(xb) # calculate loss loss = mnist_loss(preds, yb) # Adjust weights based on gradients loss.backward() . Train the Model . . Note: This is the same from part 1 . def train_epoch(model, lr, params): for xb,yb in dl: calc_grad(xb, yb, model) for p in params: p.data -= p.grad*lr p.grad.zero_() . Measure Accuracy on Batch . def batch_accuracy(xb, yb): # this is checking for each row, which column has the highest score. # p_inds, y_inds gives the index highest score, which is our prediction. p_out, p_inds = torch.max(preds,dim=1) y_out, y_inds = torch.max(yb,dim=1) # Compre predictions with actual correct = p_inds == y_inds # average how often we are right (accuracy) return correct.float().mean() . Measure Accuracy on All . . Note: This is the same from part 1 . def validate_epoch(model): # Calculate accuracy on the entire validation set accs = [batch_accuracy(model(xb), yb) for xb,yb in valid_dl] # Combine accuracy from each batch and round return round(torch.stack(accs).mean().item(), 4) . Initialize weights and biases . # When classifying 3 vs 7 in part one, we just used 30 weights. # With this problem being much harder, I will give it more weights to work with complexity = 500 w1 = init_params((28*28,complexity)) b1 = init_params(complexity) w2 = init_params((complexity,10)) b2 = init_params(10) params = w1,b1,w2,b2 . Train the Model . Below we will actually train our model. . lr = 50 # epoch means # of passes through our data (60,000 images) epochs = 30 loss_old = 9999999 for i in range(iterations): train_epoch(simple_net, lr, params) # Print Accuracy metric every 10 iterations if (i % 10 == 0) or (i == iterations - 1): print(&#39;Accuracy:&#39;+ str(round(validate_epoch(simple_net)*100,2))+&#39;%&#39;) loss_new = mnist_loss(simple_net(x),y) # Print Loss score every iteration print(&#39;Loss: &#39; + str(round(mnist_loss(simple_net(x),y).item(),5)),&quot;Loss decreased&quot; if loss_new &lt; loss_old else &quot;Loss increased&quot;) loss_old = loss_new . Accuracy:10.7% Loss: 0.10003 Loss decreased Loss: 0.10002 Loss decreased Loss: 0.09893 Loss decreased Loss: 0.09408 Loss decreased Loss: 0.09275 Loss decreased Loss: 0.09227 Loss decreased Loss: 0.0924 Loss increased Loss: 0.09199 Loss decreased Loss: 0.09156 Loss decreased Loss: 0.09231 Loss increased Accuracy:19.6% Loss: 0.09141 Loss decreased Loss: 0.09151 Loss increased Loss: 0.09128 Loss decreased Loss: 0.09118 Loss decreased Loss: 0.09135 Loss increased Loss: 0.09108 Loss decreased Loss: 0.09042 Loss decreased Loss: 0.08482 Loss decreased Loss: 0.08329 Loss decreased Loss: 0.08295 Loss decreased Accuracy:28.32% Loss: 0.08366 Loss increased Loss: 0.08272 Loss decreased Loss: 0.08259 Loss decreased Loss: 0.08258 Loss decreased Loss: 0.08245 Loss decreased Loss: 0.08249 Loss increased Loss: 0.08239 Loss decreased Loss: 0.08215 Loss decreased Loss: 0.07953 Loss decreased Accuracy:36.19% Loss: 0.07496 Loss decreased . Results . A few key points: . The Loss is not the same as the metric (Accuracy). Loss is what the models use, Accuracy is more meaningful to us humans. | We see that our loss slowly decreases each epoch. Our accuracy is getting better over time as well. | . We start at about 10% accuracy, which makes sense. With random weights we predict correctly 1/10 times. With 10 digits that sounds like a random guess. Over time, we slowly decrease the loss and after 30 epochs we are around 36% accuracy. Much better! We could keep training more to keep improving accuracy, but I think we see the idea. . This Model vs SOTA . What is different about this model than a best practice model? . This model is only 1 layer. State of the art for image recognitions will use more layers. Resnet 34 and Resnet 50 are common (34 and 50 layers). This would just mean we would alternate between the ReLu and linear layers and duplicate what we are doing with more weights and biases. | More weights and Biases. The Weights and Biases I used are fairly small - I ran this extremely quickly on a CPU. With the appropriate size weight and biases tensors, it would make way more sense to use a GPU. | Matrix Multiplication is replaced with Convolutions for image recognition. A Convolution can be thought of as matrix multiplication if you averaged some of the pixels together. This intuitively makes sense as 1 pixel in itself is meaningless without the context of other pixels. So we tie them together some. | Dropout would make our model less likely to overfit and less dependent on specific pixels. It would do this by randomly ignoring different pixels so it cannot rely on them. It&#39;s very similar to how decision trees randomly ignore variables for their splits. | Discriminate learning rates means that the learning rates are not the same for all levels of the neural network. With only 1 layer, naturally we don&#39;t worry about this. | Gradient Descent - we can adjust our learning rate based on our loss to speed up the process | Transfer learning - we can optimize our weights on a similar task so when we start trying to optimize weights on digits we aren&#39;t starting from random variables. | Keep training for as many epochs as we see our validation loss decrease | . As you can see, these are not completely different models. These are small tweaks to what we have done above that make improvements - the combination of these small tweaks and a few other tricks are what elevate these models. There are many &#39;advanced&#39; variations of Neural Networks, but the concepts are typically along the lines of above. If you boil them down to what they are really doing without all the jargon - they are pretty simple concepts. I&#39;ll cover them in future blog posts. .",
            "url": "https://isaac-flath.github.io/blog/neural%20networks/image%20classification/2020/06/21/Image-Classifier-Basics-MultiClass.html",
            "relUrl": "/neural%20networks/image%20classification/2020/06/21/Image-Classifier-Basics-MultiClass.html",
            "date": " • Jun 21, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Neural Network Basics (Part 1)",
            "content": "from fastai2.vision.all import * from fastai2.data.external import * from PIL import Image import math torch.manual_seed(100) . &lt;torch._C.Generator at 0x7f9fd6fb4d90&gt; . Intro . Today we will be working with a subset of the MNIST dataset. The goal is going to be to take an image of handwritten digits and automatically predict whether it is a 3 or a 7. We will be building a Neural Network to do this. . If you get through this and want more detail, I highly recommend checking out Deep Learning for Coders with fastai &amp; Pytorch by Jeremy Howard and Sylvain Gugger. All of the material in this guide and more is covered in much greater detail in that book. They have some awesome courses on their fast.ai website as well. . https://www.amazon.com/Deep-Learning-Coders-fastai-PyTorch/dp/1492045527 . Load the Data . Naturally, the first step is to get and load the data. We&#39;ll look at it a bit along tohe way to make sure it was loaded properly and we understand it. We will be using fastai&#39;s built in dataset feature rather than sourcing it ourself. . # This command downloads the MNIST_TINY dataset and returns the path where it was downloaded path = untar_data(URLs.MNIST_TINY) # This takes that path from above, and get the path for the threes and the sevens threes = (path/&#39;train&#39;/&#39;3&#39;).ls().sorted() sevens = (path/&#39;train&#39;/&#39;7&#39;).ls().sorted() . Let&#39;s take a look at an image. The first thing I reccomend doing for any dataset is to view something to verify you loaded it right. The second thing is to look at the size of it. This is not just for memory concerns, but you want to generally know some basics about whatever you are working with. . # Let&#39;s view what one of the images looks like im3 = Image.open(threes[1]) im3 . # Let&#39;s see what shape the underlying matrix is that represents the picture tensor(im3).shape . torch.Size([28, 28]) . What I am going to do below is put the tensor into a dataframe, and color the pixels based on the value in each place. We can clearly see that this is a 3 just from the values in the tensor. This should give a good idea for the data we are working with and how an image can be worked with. . pd.DataFrame(tensor(im3)).loc[3:24,6:20].style.set_properties(**{&#39;font-size&#39;:&#39;6pt&#39;}).background_gradient(&#39;Greys&#39;) . 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . 3 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | . 4 0 | 0 | 0 | 77 | 181 | 254 | 255 | 95 | 88 | 0 | 0 | 0 | 0 | 0 | 0 | . 5 0 | 3 | 97 | 242 | 253 | 253 | 253 | 253 | 251 | 117 | 15 | 0 | 0 | 0 | 0 | . 6 0 | 20 | 198 | 253 | 253 | 253 | 253 | 253 | 253 | 253 | 239 | 59 | 0 | 0 | 0 | . 7 0 | 0 | 108 | 248 | 253 | 244 | 220 | 231 | 253 | 253 | 253 | 138 | 0 | 0 | 0 | . 8 0 | 0 | 0 | 110 | 129 | 176 | 0 | 83 | 253 | 253 | 253 | 194 | 24 | 0 | 0 | . 9 0 | 0 | 0 | 0 | 0 | 26 | 0 | 83 | 253 | 253 | 253 | 253 | 48 | 0 | 0 | . 10 0 | 0 | 0 | 0 | 0 | 0 | 0 | 83 | 253 | 253 | 253 | 189 | 22 | 0 | 0 | . 11 0 | 0 | 0 | 0 | 0 | 0 | 0 | 83 | 253 | 253 | 253 | 138 | 0 | 0 | 0 | . 12 0 | 0 | 0 | 0 | 0 | 0 | 0 | 183 | 253 | 253 | 253 | 138 | 0 | 0 | 0 | . 13 0 | 0 | 0 | 0 | 0 | 65 | 246 | 253 | 253 | 253 | 175 | 4 | 0 | 0 | 0 | . 14 0 | 0 | 0 | 0 | 0 | 172 | 253 | 253 | 253 | 253 | 70 | 0 | 0 | 0 | 0 | . 15 0 | 0 | 0 | 0 | 0 | 66 | 253 | 253 | 253 | 253 | 238 | 54 | 0 | 0 | 0 | . 16 0 | 0 | 0 | 0 | 0 | 17 | 65 | 232 | 253 | 253 | 253 | 149 | 5 | 0 | 0 | . 17 0 | 0 | 0 | 0 | 0 | 0 | 0 | 45 | 141 | 253 | 253 | 253 | 123 | 0 | 0 | . 18 0 | 0 | 0 | 41 | 205 | 205 | 205 | 33 | 2 | 128 | 253 | 253 | 245 | 99 | 0 | . 19 0 | 0 | 0 | 50 | 253 | 253 | 253 | 213 | 131 | 179 | 253 | 253 | 231 | 59 | 0 | . 20 0 | 0 | 0 | 50 | 253 | 253 | 253 | 253 | 253 | 253 | 253 | 253 | 212 | 0 | 0 | . 21 0 | 0 | 0 | 21 | 187 | 253 | 253 | 253 | 253 | 253 | 253 | 253 | 212 | 0 | 0 | . 22 0 | 0 | 0 | 0 | 9 | 58 | 179 | 251 | 253 | 253 | 253 | 219 | 44 | 0 | 0 | . 23 0 | 0 | 0 | 0 | 0 | 0 | 0 | 139 | 253 | 253 | 130 | 49 | 0 | 0 | 0 | . 24 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | . Defining our Linear Equation . We are looking to do xw + b = y. It seems that a Neural network should use some super fancy equation in it&#39;s layers, but that&#39;s all it is. Basically the same equation everyone learns that defines a line (mx+b) . Setup . We will need a wieght matrix with 1 weight per pixel, meaning this will be a 784 row by 1 column matrix. In order to multiply this by our 784 pixels we need to frormat that in 1 row x 784 column matrix. Then we can do matrix multiplication. We are also going to add b, so let&#39;s initialize that as well. Since we haven&#39;t solved the problem yet, we don&#39;t know what good values for w and b are so we will make them random to start with. . Note: When we checked the shape above, we saw our images were 28 x 28 pixels, which is 784 total pixels. . def init_params(size, std=1.0): return (torch.randn(size)*std).requires_grad_() w = init_params((28*28,1)) b = init_params(1) . Now we just need x and y. A 784x1 matrix times a 1x784 matrix. We want all values to be between 0 and 1, so we divide by the max pixel value (255) . # open each image and convert them to a tensor threes_t = [tensor(Image.open(i)) for i in threes] sevens_t = [tensor(Image.open(i)) for i in sevens] # Get my list of tensors and &quot;stack&quot; them. Also dividing by 255 so all values are between 0 and 1 threes_s = torch.stack(threes_t).float()/255 sevens_s = torch.stack(sevens_t).float()/255 #Verify max and min pixel values torch.min(threes_s), torch.max(threes_s), torch.min(sevens_s), torch.max(sevens_s) . (tensor(0.), tensor(1.), tensor(0.), tensor(1.)) . Let&#39;s do a simple average of all our threes together and see what we get. It&#39;s a nice sanity check to see that we did things ok. We can see that after averaging, we pretty much get a three! . show_image(threes_s.mean(0)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9fdda2a410&gt; . Perfect, lets finish definining our x. We want x to have both threes and sevens, but right now they are seperate. We will use torch.cat to combine them, and .view to change the format of the matrix to the right format. Y is being defined as a long matrix with 1 row per image (prediction) and 1 column. . # combine our threes and sevens into 1 matrix. Convert Rank 3 matrix to rank 2. x = torch.cat([threes_s, sevens_s]).view(-1, 28*28) # Set my y, or dependent variable matrix. A three will be 1, and seven will be 0. So we will be prediction 0 or 1. y = tensor([1]*len(threes) + [0]*len(sevens)).unsqueeze(1) # Combine by xs and ys into 1 dataset for convenience. dset = list(zip(x,y)) x_0,y_0 = dset[0] x_0.shape,y_0 . (torch.Size([784]), tensor([1])) . Perfect. We have exactly what we need and defined above. A 784 x 1 matrix times a 1 x 784 matrix + a constanct = our prediction. Let&#39;s take a look to verify things are the right shape, and if we actually multiply these things together we get 1 prediction per image. . w.shape,x_0.shape,b.shape,y_0.shape . (torch.Size([784, 1]), torch.Size([784]), torch.Size([1]), torch.Size([1])) . print((x@w+b).shape) (x@w+b)[1:10] . torch.Size([709, 1]) . tensor([[ 3.3164], [ 5.2035], [-3.7491], [ 1.2665], [ 2.2916], [ 1.3741], [-7.6092], [ 1.3464], [ 2.7644]], grad_fn=&lt;SliceBackward&gt;) . Great, we have the right number of predictions. Obviosly the predictions are no good at predictions 0 or 1. After all, our weights and biases are all random. Let&#39;s do something about that. . We will need to do all this on our validation set as well, so let&#39;s do that here. . #collapse-hide valid_3_tens = torch.stack([tensor(Image.open(o)) for o in (path/&#39;valid&#39;/&#39;3&#39;).ls()]) valid_3_tens = valid_3_tens.float()/255 valid_7_tens = torch.stack([tensor(Image.open(o)) for o in (path/&#39;valid&#39;/&#39;7&#39;).ls()]) valid_7_tens = valid_7_tens.float()/255 valid_3_tens.shape,valid_7_tens.shape valid_x = torch.cat([valid_3_tens, valid_7_tens]).view(-1, 28*28) valid_y = tensor([1]*len(valid_3_tens) + [0]*len(valid_7_tens)).unsqueeze(1) valid_dset = list(zip(valid_x,valid_y)) . . Loss Function . We need to improve our weights and biases (w and b) and we do that using gradient descent. I have a few posts on gradient descent, feel free to check those out if you want details on how it works. Here we will use the built-in pytorch functionality. . The first thing we need to use gradient descent is we need a loss function. Let&#39;s use something simple, how far off we were. If the correct answer was 1, and we predicted a 0.5 that would be a loss of 0.5. . The one addition is that we will add something called a sigmoid. All a sigmoid is doing is ensuring that all of our predictions land between 0 and 1. We never want to predict anything outside of these ranges as those are our 2 categories. . def mnist_loss(predictions, targets): # make all prediction between 0 and 1 predictions = predictions.sigmoid() # Difference between predictions and target return torch.where(targets==1, 1-predictions, predictions).mean() . Gradient Descent . Background and Setup . predict | calculate loss | calculate gradient | subtract from weights and bias | . Ok, now we have a function we need to optimize and a loss function to tell us our error. We are ready for gradient descent. Let&#39;s create a function to change our weights. . Note: If you want more of a background on what is going on here, please take a look at my series on Gradient Descent where I dive deeper on this. We will be calculating a gradient - which are equivilant to the &quot;Path Value&quot; . # Here is the function to minimize def linear1(xb): return xb@weights + bias # Here is how we will initialize paramaters. This is just giving me random numbers. def init_params(size, std=1.0): return (torch.randn(size)*std).requires_grad_() . First, we will make sure our datasets are in a DataLoader. This is convenience class that helps manage our data and get batches.. . dl = DataLoader(dset, batch_size=256, shuffle=True) valid_dl = DataLoader(valid_dset, batch_size=256) . We are now going to get the first batch out. We&#39;ll use a batch size of 256, but feel free to change that based on your memory. You can see that we can just simply call first dl, and it creates our shuffled batch for us. . xb,yb = first(dl) xb.shape,yb.shape . (torch.Size([256, 784]), torch.Size([256, 1])) . Let&#39;s Initialize our paramaters we will need. . weights = init_params((28*28,1)) bias = init_params(1) . Calculate the Gradient . We now have our batch of x and y, and we have our weights and biases. The next step is to make a prediction. Since our batch size is 256, we see 256x1 tensor. . preds = linear1(xb) preds.shape, preds[:5] . (torch.Size([256, 1]), tensor([[-17.7688], [ -3.9593], [ -4.0014], [ 1.4874], [ 0.5148]], grad_fn=&lt;SliceBackward&gt;)) . Now we calculate our loss to see how we did. Probably not well considering all our weights at this point are random. . loss = mnist_loss(preds, yb) loss . tensor(0.5678, grad_fn=&lt;MeanBackward0&gt;) . Let&#39;s calculate our Gradients . loss.backward() weights.grad.shape,weights.grad.mean(),bias.grad . (torch.Size([784, 1]), tensor(-0.0011), tensor([-0.0071])) . Since we are going to want to calculate gradients every since step, let&#39;s create a function that we can call that does these three steps above. Let&#39;s put all that in a function. From here on out, we will use this function. . Note: It&#8217;s always a good idea to periodically reviewing and trying to simplify re-usable code. I reccomend doing following the above approach, make something that works - then simplify. It often wastes a lot of time trying to write things in the most perfect way from the start. . def calc_grad(xb, yb, model): preds = model(xb) loss = mnist_loss(preds, yb) loss.backward() . calc_grad(xb, yb, linear1) weights.grad.mean(),bias.grad . (tensor(-0.0022), tensor([-0.0142])) . weights.grad.zero_() bias.grad.zero_(); . Training the Model . Now we are ready to create a function that trains for 1 epoch. . Note: Epoch is just a fancy way of saying 1 pass through all our data. . def train_epoch(model, lr, params): for xb,yb in dl: calc_grad(xb, yb, model) for p in params: p.data -= p.grad*lr p.grad.zero_() . Naturally, we want to be able to measure accuracy. It&#39;s hard for us to gauge how well the model is doing from our loss function. We will create an accuracy metric to look at accuracy for that batch. . Note: A loss function is designed to be good for gradient descent. A Metric is designed to be good for human understanding. This is why they are different sometimes. . def batch_accuracy(xb, yb): preds = xb.sigmoid() correct = (preds&gt;0.5) == yb return correct.float().mean() . batch_accuracy(linear1(xb), yb) . tensor(0.4180) . Looking at accuracy of our batch is great, but we also want to look at our accuracy for the validation set. This is our way to do that using the accuracy funcion we just defined. . def validate_epoch(model): accs = [batch_accuracy(model(xb), yb) for xb,yb in valid_dl] return round(torch.stack(accs).mean().item(), 4) . validate_epoch(linear1) . 0.4138 . Awesome! Let&#39;s throw this all in a loop and see what we get. . params = weights,bias lr = 1. for i in range(20): train_epoch(linear1, lr, params) print(validate_epoch(linear1), end=&#39; &#39;) . 0.5249 0.6097 0.7038 0.7628 0.8165 0.8439 0.8685 0.8839 0.8922 0.8984 0.9071 0.9097 0.9136 0.9162 0.9176 0.9202 0.9215 0.9267 0.9311 0.9319 . Linear Recap . Lots of stuff, but let&#39;s recap really what we did: . Make a prediction | Measure how we did | Change our weights so we do slightly better next time | Print out accuracy metrics along the way so we can see how we are doing | . This is a huge start, but what we have is a linear model. Now we need to add non-linearities so that we can have a true Neural Network. . ReLu . What is it? . First, a ReLu is our non-linearity in a neural network. A neural network is just alternating linear and nonlinear layers. We defined the Linear layer above, here we will talk about the non-linear ones. So what exactly does the non-linear layer do? It&#39;s actually much simpler than people like to believe, it&#39;s just a max. . For example, I am going to apply a ReLu to a matrix. . $ begin{bmatrix}-1&amp;1 -1&amp;-1 0&amp;0 0&amp;1 1&amp;-1 1&amp;0 -1&amp;0 -1&amp;-1 1&amp;1 end{bmatrix}$ $=&gt;$ $ begin{bmatrix}0&amp;1 0&amp;0 0&amp;0 0&amp;1 1&amp;0 1&amp;0 0&amp;0 0&amp;0 1&amp;1 end{bmatrix}$ . As you will see I just took max(x,0). Another way of saying that is I replaced any negative values with 0. That&#39;s all a ReLu is. . In a Neural Network . These ReLus go between our linear layers. Here&#39;s what a simple Neural Net looks like. . # initialize random weights. # The number 30 here can be adjusted for more a less model complexity. Future posts will talk more about what that is. w1 = init_params((28*28,30)) b1 = init_params(30) w2 = init_params((30,1)) b2 = init_params(1) . # Here&#39;s a simple Neural Network. # This can have more layers by duplicating the patten seen below, this is just the simplest model. def simple_net(xb): res = xb@w1 + b1 #Linear res = res.max(tensor(0.0)) #ReLu res = res@w2 + b2 #Linear return res . Train the Full Neural Network . So we have our new model with new weights. It&#39;s more than just the linear model, so how do we use gradient descent? We now have 4 weights (w1,w2,b1,b2). . Turns our it&#39;s exactly what we already did. Let&#39;s add the new paramaters to our paramsm, and change out the linear model with the simple_net we just defined. We end up with a pretty decent accuracy! . w1 = init_params((28*28,30)) b1 = init_params(30) w2 = init_params((30,1)) b2 = init_params(1) . params = w1,b1,w2,b2 lr = 1 for i in range(20): train_epoch(simple_net, lr, params) print(validate_epoch(simple_net), end=&#39; &#39;) . 0.6711 0.8028 0.8865 0.9198 0.9245 0.9225 0.9291 0.9223 0.9402 0.9433 0.9343 0.9433 0.9392 0.9392 0.9463 0.9431 0.9476 0.9489 0.9457 0.9528 . Recap of Tensor Shapes . Understanding the shapes of these tensors and how the network works is crucial. Here&#39;s the network we built. You can see how each layer can fit into the next layer. . x.shape,w1.shape,b1.shape,w2.shape,b2.shape . (torch.Size([709, 784]), torch.Size([784, 30]), torch.Size([30]), torch.Size([30, 1]), torch.Size([1])) . . What More? . This is a Neural Network. Now we can do tweaks to enhance performance. I will talk about those in future posts, but here&#39;s a few concepts. . Instead of a Linear Layer, A ReLu, then a linear layer - Can we add more layers to have a deeper net? | What if we average some of the pixels in our image together before dong matrix multiplication (ie a convolutions)? | Can we randomly ignore pixels to prevent overfitting (ie dropout)? | . There are many &#39;advanced&#39; variations of Neural Networks, but the concepts are typically along the lines of above. If you boil them down to what they are really doing - they are pretty simple concepts. .",
            "url": "https://isaac-flath.github.io/blog/neural%20networks/image%20classification/2020/06/19/Image-Classifier-Basics.html",
            "relUrl": "/neural%20networks/image%20classification/2020/06/19/Image-Classifier-Basics.html",
            "date": " • Jun 19, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Gradient Descent for Linear Regression (Part 2)",
            "content": "Why part 2? . I have done a couple blog posts on Gradient Descent for linear regression focusing on the basic algorithm. In this post, I will be covering some more advanced gradient descent algorithms. I will post as I complete a section rather than waiting until I have every variation posted. This is partially to show some popular ones, but the more important thing to understand from this post is that all these advanced algorithms are really just minor tweaks on the basic algorithm. . Goal Recap . The goal of linear regression is to find parameter values that fit a linear function to data points.  The goodness of fit is measured by a cost function.  The lower the cost, the better the model.  Gradient Descent is a method to minimize a cost function.  Gradient descent is a widely used tool and is used frequently in tuning predictive models.  It’s important to understand the method so you can apply it to various models and are not limited to using black box models. This approach will use the sum of squares cost function to take a predicted line and slowly change the regression coefficients until the line is a line of best fit. . This post will cover the algorithms. Part 4 of this series will focus on scaling this up to larger datasets. One of the primary tools of scaling is using stochastic gradient descent, which is just a fancy way to say &quot;just use a subset of the points instead of all of them&quot;. . Background . Our goal is to define the equation $y= theta_0+ theta_1x$. This is the same thing as $y=mx+b$. For this post I will use $y=mx+b$ language with $m$ being the slope and $b$ being the y intercept. . Note: In order to adjust $m$, I will take $m$ - &lt;$m$ PathValue&gt; * &lt;adj $ alpha$&gt;. . . Note: In order to adjust $b$, I will take $b$ - &lt;$b$ PathValue&gt; * &lt;adj $ alpha$&gt;. Each of these advanced algorithms either change the Path Value, or change $ alpha$. I will show what the calculation for each is for each algorthm is, have a written explanation, and python code that illustrates it. . Setup . Here is where I load libraries, define my dataset, and create a graphing function. . #collapse-hide import matplotlib.pyplot as plt import pandas as pd import numpy as np import math from IPython.display import clear_output from time import sleep np.random.seed(44) xs = np.random.randint(-100,100,100) ys = xs * np.random.randint(-10,10) + 100 # + np.random.randint(-200,200,50) cycles = 50 def graph_gradient_descent(values,cycles, figures,step): plt.figure(figsize=(20,10)) cols = 3 rows = math.ceil(figures/3) for x in range(1,figures+1): plt.subplot(rows,cols,x) plt.scatter(values[&#39;x&#39;],values[&#39;y&#39;]) plt.scatter(values[&#39;x&#39;],values[&#39;cycle0&#39;]) plt.scatter(values[&#39;x&#39;],values[&#39;cycle&#39;+str(x*step)]) labels = [&#39;y&#39;,&#39;initial&#39;,&#39;cycle&#39;+str(x*step)] plt.legend(labels) plt.ylim(-1000,1000) plt.xlim(-100,100) . . Basic Gradient Descent . This is the basic gradient descent algorithm that all others are based on. If you are not clear on how gradient descent works, please refer to the background section for a review or Gradient Descent Part 1 Blog Post for more details. I will use this same format below for each algorithm, and change only what is necessary for easier comparison. . Inputs . $ alpha = learning rate$ . n = number of data points . New Formulas . $PathValue_m = PathValue_bx$ . $PathValue_b = y_{pred}-y_{obs}$ . Each variation after this does 1 of 3 things to modify this algorithm: . Adjusts $ alpha$ by some amount | Adjust $PathValue$ by some amount. | Adjust both $ alpha$ and $PathValue$. | . Really logically speaking, what else can you do? These are the only values that are used to adjust our values, so any tweaks must involve those. We can modify number through addition, subtraction, multiplication, and division: If you get stuck, try to get back to those basics. . Python Function . alpha = 0.0005 def gradient_descent(xs,ys,alpha,cycles): n = len(xs) adj_alpha = (1/n)*alpha values = pd.DataFrame({&#39;x&#39;:xs,&#39;y&#39;:ys}) weights = pd.DataFrame({&#39;cycle0&#39;:[1,1,0,0]},index=[&#39;m&#39;,&#39;b&#39;,&#39;pvb&#39;,&#39;pvm&#39;]) values[&#39;cycle0&#39;] = weights[&#39;cycle0&#39;].m*values[&#39;x&#39;] + weights[&#39;cycle0&#39;].b for cycle in range(1,cycles+1): p_cycle_name = &#39;cycle&#39;+str(cycle-1) c_cycle_name = &#39;cycle&#39;+str(cycle) error = values[p_cycle_name]-values[&#39;y&#39;] path_value_b = sum(error) path_value_m = sum(error * values[&#39;x&#39;]) new_m = weights[p_cycle_name].m - path_value_m * adj_alpha new_b = weights[p_cycle_name].b - path_value_b * adj_alpha weights[c_cycle_name] = [new_m, new_b, path_value_m, path_value_b] y_pred = weights[c_cycle_name].m*values[&#39;x&#39;] + weights[c_cycle_name].b values[c_cycle_name] = y_pred return weights,values weights, values = gradient_descent(xs,ys,alpha,cycles) graph_gradient_descent(values,cycles,12,2) . Momentum . Concept . The idea of momentum is to use the previous path values to influence the new path value. It&#39;s taking a weighted average of the previous path value and the new calculation. This is referred to as momentum because it is using the momentum from previous points to change the size of the step to take. To control what kind of weighted average is used, we define $ beta$. . This is useful and effective because we want to have very large steps early on, but the closer we get to the optimal values the lower we want our learning rate to be. This allows us to do that, and if we overshoot then it will average with previous path values and lower the step size. This allows for larger steps while minimizing the risk of our gradient descent going out of control. If you overshoot the optimal weights the weighted average will decrease the step size and keep going, eventually settling on the minimum. A very handy feature! . What is different . What is different: $PathValue$ has changed and is using a new input $ beta$ . If you look at $PathValue_b$ you will notice a change in this formula. $PathValue_m$ multiplies $PathValue_b$ by our x value for that point, so it is effected as well. . New Inputs . $ beta = 0.9$ . New Formulas . $ alpha_{adj} = frac{1}{n} alpha$ . $PathValue_m$ = $PathValue_bx$ . $PathValue_b = ( beta)(PathValue_{b_{previous}}) + (1 - beta)(y_{pred}-y_{obs})$ . Python Function . alpha = 0.0001 beta = 0.9 def gradient_descent_momentum(xs,ys,alpha,cycles,beta): n = len(xs) adj_alpha = (1/n)*alpha values = pd.DataFrame({&#39;x&#39;:xs,&#39;y&#39;:ys}) weights = pd.DataFrame({&#39;cycle0&#39;:[1,1,0,0]},index=[&#39;m&#39;,&#39;b&#39;,&#39;pvm&#39;,&#39;pvb&#39;]) values[&#39;cycle0&#39;] = weights[&#39;cycle0&#39;].m*values[&#39;x&#39;] + weights[&#39;cycle0&#39;].b for cycle in range(1,cycles+1): p_cycle_name = &#39;cycle&#39;+str(cycle-1) c_cycle_name = &#39;cycle&#39;+str(cycle) error = values[p_cycle_name]-values[&#39;y&#39;] path_value_b = sum(error) path_value_m = sum(error * values[&#39;x&#39;]) if cycle &gt; 1: path_value_b = (beta) * weights[p_cycle_name].pvb + (1-beta) * path_value_b path_value_m = (beta) * weights[p_cycle_name].pvm + (1-beta) * path_value_m new_m = weights[p_cycle_name].m - path_value_m * adj_alpha new_b = weights[p_cycle_name].b - path_value_b * adj_alpha weights[c_cycle_name] = [new_m, new_b, path_value_m, path_value_b] y_pred = weights[c_cycle_name].m*values[&#39;x&#39;] + weights[c_cycle_name].b values[c_cycle_name] = y_pred return weights,values weights, values = gradient_descent_momentum(xs,ys,alpha,cycles,beta) graph_gradient_descent(values,cycles,12,3) . RMSProp . Concept . The idea of RMS prop is that we will adjust out learning rate based on how large our error rate it. If we have a very large error, we will take a larger step. With a smaller error, we will take a smaller step. This minimizes the changces that we overshoot the ideal weights. This is accomplished by diving the learning rate by an weighted exponential average of the previous path values. To control what kind of weighted average is used, we define $ beta$. . This is useful and effective because we want to have very large steps early on with a big learning rate, but the closer we get to the optimal values the lower we want our learning rate to be. This is exactly what RMS prop does - adjust out learning rate based on our error rate. This allows for larger steps with a bigger learning rate while minimizing the risk of our gradient descent going out of control. It has similar benefits of momentum, but approaches it by modifying the learning rath rather than the path value. . What is different . What is different: we have an alpha_multiplier for each variable that is calculated each cycle. When calculating the new value, we divide our learning rate $ alpha$ by the square root of this alpha multiplier. The alpha multiplier uses a new input, $ beta$ . Our alpha multiplier is calculated with this formula. . $alphamultiplier_b = ( beta)(alphamultiplier_{b_{previous}}) + (1 - beta)((y_{pred}-y_{obs})^2)$ . $alphamultiplier_m = ( beta)(alphamultiplier_{m_{previous}}) + (1 - beta)(x(y_{pred}-y_{obs})^2)$ . Here&#39;s the path value for our Regular Gradient Descent | . $new_m = m - PathValue_m * frac{ alpha}{n}$ . $new_b = b - PathValue_b * frac{ alpha}{n}$ . Here&#39;s the path value for our RMS Prop | . $new_m = m - PathValue_m * frac{ alpha}{n sqrt{alphamultiplier_m}}$ . $new_b = b - PathValue_b * frac{ alpha}{n sqrt{alphamultiplier_b}}$ . Python Function . beta = 0.9 alpha = 500 def gradient_descent_momentum(xs,ys,alpha,cycles,beta): n = len(xs) adj_alpha = (1/n)*alpha values = pd.DataFrame({&#39;x&#39;:xs,&#39;y&#39;:ys}) weights = pd.DataFrame({&#39;cycle0&#39;:[1,1,0,0,0,0]},index=[&#39;m&#39;,&#39;b&#39;,&#39;pvm&#39;,&#39;pvb&#39;,&#39;am_m&#39;,&#39;am_b&#39;]) values[&#39;cycle0&#39;] = weights[&#39;cycle0&#39;].m*values[&#39;x&#39;] + weights[&#39;cycle0&#39;].b for cycle in range(1,cycles+1): p_cycle_name = &#39;cycle&#39;+str(cycle-1) c_cycle_name = &#39;cycle&#39;+str(cycle) error = values[p_cycle_name]-values[&#39;y&#39;] path_value_b = sum(error) path_value_m = sum(error * values[&#39;x&#39;]) alpha_multiplier_b = abs(path_value_b)**2 alpha_multiplier_m = abs(path_value_m)**2 if cycle &gt; 1: alpha_multiplier_b = (beta) * weights[p_cycle_name].am_b + (1-beta) * alpha_multiplier_b alpha_multiplier_m = (beta) * weights[p_cycle_name].am_m + (1-beta) * alpha_multiplier_m new_m = weights[p_cycle_name].m - path_value_m * adj_alpha / math.sqrt(alpha_multiplier_m) new_b = weights[p_cycle_name].b - path_value_b * adj_alpha / math.sqrt(alpha_multiplier_b) weights[c_cycle_name] = [new_m, new_b, path_value_m, path_value_b, alpha_multiplier_m, alpha_multiplier_b] y_pred = weights[c_cycle_name].m*values[&#39;x&#39;] + weights[c_cycle_name].b values[c_cycle_name] = y_pred return weights,values weights, values = gradient_descent_momentum(xs,ys,alpha,cycles,beta) graph_gradient_descent(values,cycles,15,2) . Adam . Concept . The idea of Adam is that there are really nice properties to RMS Prop as well as momentum, so why not do both at the same time. We will modify our path value using the momentum formula and we will modify our learning rate using RMSProp formula. To control what kind of weighted average is used, we define beta_rmsprop and beta_momentum. We can have a pretty big learning rate without overshooting. . This is useful and effective because we want the ability to pick up speed like momentum does, but also want to minimize overshooting. Basically we pick up momementum when we are far from the minimum, but we slow down as we get close before we overshoot. . beta_rmsprop = 0.9 beta_momentum = 0.7 alpha = 200 def gradient_descent_momentum(xs,ys,alpha,cycles,beta_rmsprop,beta_momentum): n = len(xs) adj_alpha = (1/n)*alpha values = pd.DataFrame({&#39;x&#39;:xs,&#39;y&#39;:ys}) weights = pd.DataFrame({&#39;cycle0&#39;:[1,1,0,0,0,0]},index=[&#39;m&#39;,&#39;b&#39;,&#39;pvm&#39;,&#39;pvb&#39;,&#39;am_m&#39;,&#39;am_b&#39;]) values[&#39;cycle0&#39;] = weights[&#39;cycle0&#39;].m*values[&#39;x&#39;] + weights[&#39;cycle0&#39;].b for cycle in range(1,cycles+1): p_cycle_name = &#39;cycle&#39;+str(cycle-1) c_cycle_name = &#39;cycle&#39;+str(cycle) error = values[p_cycle_name]-values[&#39;y&#39;] path_value_b = sum(error) path_value_m = sum(error * values[&#39;x&#39;]) if cycle &gt; 1: path_value_b = (beta_momentum) * weights[p_cycle_name].pvb + (1-beta_momentum) * path_value_b path_value_m = (beta_momentum) * weights[p_cycle_name].pvm + (1-beta_momentum) * path_value_m alpha_multiplier_b = abs(path_value_b)**2 alpha_multiplier_m = abs(path_value_m)**2 if cycle &gt; 1: alpha_multiplier_b = (beta_rmsprop) * weights[p_cycle_name].am_b + (1-beta_rmsprop) * alpha_multiplier_b alpha_multiplier_m = (beta_rmsprop) * weights[p_cycle_name].am_m + (1-beta_rmsprop) * alpha_multiplier_m new_m = weights[p_cycle_name].m - path_value_m * adj_alpha / math.sqrt(alpha_multiplier_m) new_b = weights[p_cycle_name].b - path_value_b * adj_alpha / math.sqrt(alpha_multiplier_b) weights[c_cycle_name] = [new_m, new_b, path_value_m, path_value_b, alpha_multiplier_m, alpha_multiplier_b] y_pred = weights[c_cycle_name].m*values[&#39;x&#39;] + weights[c_cycle_name].b values[c_cycle_name] = y_pred return weights,values weights, values = gradient_descent_momentum(xs,ys,alpha,cycles,beta_rmsprop,beta_momentum) graph_gradient_descent(values,cycles,15,2) .",
            "url": "https://isaac-flath.github.io/blog/gradient%20descent/2020/06/11/GradientDescentforLinearRegression-P2.html",
            "relUrl": "/gradient%20descent/2020/06/11/GradientDescentforLinearRegression-P2.html",
            "date": " • Jun 11, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Solving $Ax=b$ - The Complete Solution (18.06_L8)",
            "content": "Ax=b . $ left[ begin{array}{cccc|c} 1&amp;2&amp;2&amp;2&amp;b1 2&amp;4&amp;6&amp;8&amp;b2 3&amp;6&amp;8&amp;10&amp;b3 end{array} right]$ . Note: You may notice not all rows and columns are independent Let&#39;s do elimination to start solving. . $ left[ begin{array}{cccc|c} 1&amp;2&amp;2&amp;2&amp;b_1 2&amp;4&amp;6&amp;8&amp;b_2 3&amp;6&amp;8&amp;10&amp;b_3 end{array} right]$ $=&gt;$ $ left[ begin{array}{cccc|c} 1&amp;2&amp;2&amp;2&amp;b_1 0&amp;0&amp;2&amp;4&amp;b_2-2b_1 0&amp;0&amp;2&amp;4&amp;b_3-3b_1 end{array} right]$ $=&gt;$ $ left[ begin{array}{cccc|c} 1&amp;2&amp;2&amp;2&amp;b_1 0&amp;0&amp;2&amp;4&amp;b_2-2b_1 0&amp;0&amp;0&amp;0&amp;b_3-b_2-b_1 end{array} right]$ . Well that makes sense. We can see intuitively we that the last row - the second - the first gives us 0. . Solvability condition on b . Solvable when b is in $C(A)$ . Note: Column space of A $C(A)$ is all linear combinations of columns of A | If a combination of A gives zero row, then the same combinations of entries of b must give 0 | . Find Complete Solution . Find $x_{particular}$ . Set all free variables to 0 | Solve $Ax=b$ for pivot variables | Set all free variables to 0 . Free variable are rows that do not have a pivot column. These free variables can be set to anything, so we set them to the most convenient thing 0 and do back substitution. . $ left[ begin{array}{cccc} 1&amp;2&amp;2&amp;2 0&amp;0&amp;2&amp;4 0&amp;0&amp;0&amp;0 end{array} right]$ $ left[ begin{array}{cccc} x_1 0 x_3 0 end{array} right]$ $=$ $ left[ begin{array}{ccc} 1 3 0 end{array} right]$ . Solve $Ax-b$ for pivot variables. . $x_1 + 2x_3 = 1$ $2x_3 = 3$ . This means . $x_3 = 3/2$ and $x_1 = -2$ . Put those into out x and we have. . $x_p =$ $ left[ begin{array}{cccc} -2 0 3/2 0 end{array} right]$ . Find all Solutions . Find anything in $x_{nullspace}$ | $X=X_p + X_n$ . Note: The nullspace are any values of x that solve for 0. So naturally the x particular solution + any combination of 0 is still the solution. $x_{complete} = $ $ left[ begin{array}{cccc} -2 0 3/2 0 end{array} right]$ $+c_1$ $ left[ begin{array}{cccc} -2 1 0 0 end{array} right]$ $+c_1$ $ left[ begin{array}{cccc} 2 0 -2 1 end{array} right]$ |",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/06/06/18.06_8_Solving-Ax=b-row-reduced-form-R.html",
            "relUrl": "/linear%20algebra/2020/06/06/18.06_8_Solving-Ax=b-row-reduced-form-R.html",
            "date": " • Jun 6, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Gradient Descent for Linear Regression (Part 1B)",
            "content": "Why part 1B? . I have been getting questions about the initial Gradient Descent Post. The questions boil down to &quot;So with 2 points I can define a line, but I could already do that. What I need is to fit a line where points aren&#39;t perfect and I have lots of them. How do I use gradient descent in a more complicated problem? . This post will quickly recap the initial Gradient Descent for Linear Regression post, show that methodology applied in a google sheet so you can see each calculation, and then scale that methodology to more points. . Goal Recap . The goal of linear regression is to find parameter values that fit a linear function to data points.  The goodness of fit is measured by a cost function.  The lower the cost, the better the model.  Gradient Descent is a method to minimize a cost function.  Gradient descent is a widely used tool and is used frequently in tuning predictive models.  It’s important to understand the method so you can apply it to various models and are not limited to using black box models. . I will use the sum of squares cost function to take a predicted line and slowly change the regression coefficients until the line is a line of best fit. Here&#39;s what it looks like before and after 24 iterations of gradient descent. As you can see, after 24 iterations our predicted points are getting pretty close to a best fit. You will be able to use the method defined here to scale this to as many points as you have. . . In the first blog we showed this table for how we calculate out prediction. Because we are talking about a linear problem, y = mx + b is the equation, or in calculus terms $y = theta_0+ theta_1x$. We could take this table and expand it down to include $x_3$ all the way through $x_n$ to represent our dataset. . . The tree below from the first blog illustrates how to solve for cost as well as how to improve the values of $ theta$ to minimize cost in the 2 point problem defined there. So the question is, how would we modify this tree for more points? Well, with more data points there would be more edges originating at $J$, and with more features there would be more thetas originating from the predicted values, but the same concept can be applied to these more complicated examples. Specifically, here is what I would change for a more complicated example with more features: . First, we have a branch for $x^1$ and a branch for $x^2$. These branches are almost identical, other than it being for the 2nd point vs the 1st point. So the first step is to add a branch off of $J = A^1 + a^2$ for $x^3$ all the way to $x^n$. | The second step is to take our formula $1/2 * (y_{pred} - y_{obs})^2$ and change $1/2$ to 1 over &lt;# of data points&gt;. This isn&#39;t strictly neccesary, but it makes the values of J we see a bit more intiutive and scaled. | The third thing is to multiply our path values by 1 over &lt;# of data points&gt;. Again, this isn&#39;t strictly neccesary but it makes setting a learning rate much more intuitive rather than having to do something more complicated to scale our learning rate based on the number of points we have. As a refresher, the path value for theta 1 was $ theta_1 ; path ;value = x^1 (y^1_{pred} - y^1_{obs}) (1) + x^2 (y^2_{pred} - y^2_{obs}) (1)$, which by multiplying values from the edges in the chart together. The path value for theta 1 will now be $ theta_1 ; path ;value = (x^1 (y^1_{pred} - y^1_{obs}) (1) + x^2 (y^2_{pred} - y^2_{obs}) (1)) * frac{1}{&lt; # features&gt;)}$. We will do that for the path value formula for $ theta_0$ as well. | . Just like with 2 points, we will multiply the path value by $ alpha$, and subtract that from that $ theta$ to improve our predictions . See this actually work . I have created a google sheet that walks through these cauculations. I strongly reccomend walking through each cell calculation and matching it up to the chart above. Star with the 2Points_Linear_Scalable tab. You can then go to the More_Points_Linear tab and see that it&#39;s the exact same formulas and calculations. . Click here for the Google Sheet . For bonus points, you can start to see what a more advanced gradient descent algorithm is on the Momentum tab. If you look through all the formulas, you will see it&#39;s almost the same thing - but instead of using just the new path value we are doing a weighted average of the path value with the previous path value. .",
            "url": "https://isaac-flath.github.io/blog/gradient%20descent/2020/06/01/GradientDescentforLinearRegression-P1B.html",
            "relUrl": "/gradient%20descent/2020/06/01/GradientDescentforLinearRegression-P1B.html",
            "date": " • Jun 1, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Column Space and Null Space (18.06_L7)",
            "content": "Ax=0 . $A =$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 2&amp;4&amp;6&amp;8 3&amp;6&amp;8&amp;10 end{bmatrix}$ . Note: You may notice not all rows and columns are independent Let&#39;s do elimination to start solving. . $ begin{bmatrix} 1&amp;2&amp;2&amp;2 2&amp;4&amp;6&amp;8 3&amp;6&amp;8&amp;10 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 0&amp;0&amp;2&amp;4 0&amp;0&amp;2&amp;4 end{bmatrix}$ . Uh oh. Now I see a 0 in the pivot position and I cannot do a row exchange. Really that&#39;s just telling me that the now is just a combination of earlier columns. It&#39;s depending on earlier columns. Let&#39;s just go on and use the next column as the pivot for that row. . $A=$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 2&amp;4&amp;6&amp;8 3&amp;6&amp;8&amp;10 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 0&amp;0&amp;2&amp;4 0&amp;0&amp;2&amp;4 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 0&amp;0&amp;2&amp;4 0&amp;0&amp;0&amp;0 end{bmatrix}$ $=U$ . Note: We have 2 pivots (aka rank 2). Row 1, Column 1 and Row 2, Column 3. . Special Solutions. . Let&#39;s write out $U$ in matrix in equation form to see what we have. . $x_1+2x_2+2x_3+2x_4=0$ . $2x_3+4x_4=0$ . Let&#39;s call the columns with a pivot a pivot column, and ones without a free column. So we have 2 pivot columns and 2 free columns. . Let&#39;s assign some values to the free columns, then solve for the pivot columns using back substitution. We&#39;ll call these special solutions. . $x=$ $ begin{bmatrix} 1 0 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} -2 1 0 0 end{bmatrix}$ $=&gt;$ $C$ $ begin{bmatrix} -2 1 0 0 end{bmatrix}$ . Let&#39;s put 1 in the other free variable. . $x=$ $ begin{bmatrix} 0 1 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 2 0 -2 1 end{bmatrix}$ $=&gt;$ $C$ $ begin{bmatrix} 2 0 -2 1 end{bmatrix}$ . Great. Our entire nullspace is a linear combination of these 2 special solutions. There will be 1 special solution for each free variable. In this case there were 2 (free columns, rank, free variables, etc). . $C$ $ begin{bmatrix} -2 1 0 0 end{bmatrix}$ $+d$ $ begin{bmatrix} 2 0 -2 1 end{bmatrix}$ . Reduced Row Echelon Form ($R$) . Reduced row echelon form has zeros above and below pivots, and the pivots are = 1. Let&#39;s do this using elimination. . $U=$ $ begin{bmatrix} 1&amp;2&amp;2&amp;2 0&amp;0&amp;2&amp;4 0&amp;0&amp;0&amp;0 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;0&amp;-2 0&amp;0&amp;2&amp;4 0&amp;0&amp;0&amp;0 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;0&amp;-2 0&amp;0&amp;1&amp;2 0&amp;0&amp;0&amp;0 end{bmatrix}$ $=R$ . Note: This row of 0&#8217;s was created because elimination identified that row 3 is just a combination of rows 1 and 2. Why this form? . We see in the pivot columns we see $I$ $ begin{bmatrix}1&amp;0 0&amp;1 end{bmatrix}$ . In the free columns we see the opposite of the nullspace definintions we found above $ begin{bmatrix}2&amp;-2 0&amp;2 end{bmatrix}$ . Solve the transpose . $A=$ $ begin{bmatrix} 1&amp;2&amp;3 2&amp;4&amp;6 2&amp;6&amp;8 2&amp;8&amp;10 end{bmatrix}$ . Elimination from $A$ -&gt; $U$ . $ begin{bmatrix} 1&amp;2&amp;3 2&amp;4&amp;6 2&amp;6&amp;8 2&amp;8&amp;10 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;3 0&amp;0&amp;0 0&amp;2&amp;2 0&amp;4&amp;4 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;2&amp;3 0&amp;2&amp;2 0&amp;0&amp;0 0&amp;0&amp;0 end{bmatrix}$ . Note: Notice that I did a row exchange to do this elimination and ended with a rank 2, which was the same as with the transpose. . Solve for Nullspace . There&#39;s 1 free column, so you fill in a 1 in the free column. $x=$ $ begin{bmatrix} 1 end{bmatrix}$ Then with back substution solve for the pivot columns. The solution is any linear combination of this, which is a line in the null space. . $$x=C begin{bmatrix}-1 -1 1 end{bmatrix}$$ . Row Reduction from $U$ -&gt; $R$ . Row Echelon Form . $ begin{bmatrix} 1&amp;2&amp;3 0&amp;2&amp;2 0&amp;0&amp;0 0&amp;0&amp;0 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;0&amp;1 0&amp;2&amp;2 0&amp;0&amp;0 0&amp;0&amp;0 end{bmatrix}$ $=&gt;$ $ begin{bmatrix} 1&amp;0&amp;1 0&amp;1&amp;1 0&amp;0&amp;0 0&amp;0&amp;0 end{bmatrix}$ $=R$ . We see the identity matrix in the pivot columns, and the opposite of our pivot nullspace varibales in the free column. Perfect! .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/17/18.06_7_pivot_variables_special_solutions.html",
            "relUrl": "/linear%20algebra/2020/05/17/18.06_7_pivot_variables_special_solutions.html",
            "date": " • May 17, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Column Space and Null Space (18.06_L6)",
            "content": "Background . We started on this topic in the last post, so much this section is review - but critical for the upcoming discussion. . Vector Spaces . To have a vector space you need to be able to: . Add any vectors and still be within the space | Multiply by any number and stay within space | Take any linear combination and stay within space | Examples . $R^2$ is a vector space. This is all real number vectors with 2 components. Here&#39;s a few examples. . $ begin{bmatrix}3 2 end{bmatrix}$, $ begin{bmatrix}0 0 end{bmatrix}$, $ begin{bmatrix} pi e end{bmatrix}$ . $R^3$ is another vector space, but it contains all real 3D vectors. Here&#39;s a few examples. . $ begin{bmatrix}3 2 5 end{bmatrix}$, $ begin{bmatrix}3 2 0 end{bmatrix}$, $ begin{bmatrix}0 0 0 end{bmatrix}$, $ begin{bmatrix} pi e 5 end{bmatrix}$ . $R^n$ is another with all column vectors with $n$ real components. . Subspaces . What if we just want a piece of $R^n$? We still need to be able to add vectors and multiply it together. So what are some subspaces? . A line through $R^n$ that goes through the origin. Any multiple of a point on a line is still on the line. We need the origin because you can mutliply any vector by 0, which would give you the origin. | Just the Origin is a subspace. You can add it to itelf, multiply it by anything, and take any combination and you will stil lhave the origin. | In $R^3$ and above, a plane through the origin is also a subspace. | Combinations of Subspaces . If I have 2 subspaces, then all vectors in P or L or both does not make a subspace. I can&#39;t add all together. In $R^3$ I would have to make a cube which would be all of $R^3$. . However, if you all points that are in both subspaces does make a subspace it is a subspace. If you think about it, by definition 2 Vectors in the intersection are for the subspace 1 and they are both in subspace 2. We already know that if you add 2 vectors in subspace 1 you get another vector in subspace 1. We also know the same thing about subspace 2. So really, any linear combination has to be in both subspaces (probably a smaller subspace). . Subspace from a matrix . Column Space . $ begin{bmatrix}1&amp;1&amp;2 2&amp;1&amp;3 3&amp;1&amp;4 4&amp;1&amp;5 end{bmatrix}$ . Columns are in $R^4$ and all their linear combinations are a subspace. So we have 3 subspaces, 1 for each column. So the full subspace for this matrix must have a linear combination of all columns, or all 3 subspaces. With 3 columns do we get all of $R^4$? What exactly do we get? How big is this subspace? Does $Ax=b$ have a solution for every $b$? Which $b$ values are ok? . We know it doesn&#39;t, because we have 4 equations but only 3 unknowns. In the proper form we see. . $Ax=b$ $ begin{bmatrix}1&amp;1&amp;2 2&amp;1&amp;3 3&amp;1&amp;4 4&amp;1&amp;5 end{bmatrix}$ $ begin{bmatrix}x_1 x_2 x_3 end{bmatrix}$ $=$ $ begin{bmatrix}b_1 b_2 b_3 b_4 end{bmatrix}$ . Now, just because we can&#39;t solve for every b doesn&#39;t mean we can&#39;t solve it for any b. So which $b$&#39;s allow this to be solved? Obviously we can solve for the 0 vector. Obviously we can solve for (1,2,3,4) or any other column as we can have $x_1 = 1$ with the other x&#39;s being 0. We could also solve for multiples of any column because $x_2$ could equal 2 or 3 with other uknowns being 0. . Note: To Summarize, Ax=b can be solved with $b$ is in $C(A)$, the column space of A. Now column 3 and column 1 are redundant, so we can throw away column 3. Column 1 + column 2 = column 3. So really linear combinations of the first 2 columns gives the same subspace as linear combinations of all 3 columns. So in all practicality, we have 2 equations with 4 unknowns with 2 of the columns sitting on the same plane. . Nullspace . $ begin{bmatrix}1&amp;1&amp;2 2&amp;1&amp;3 3&amp;1&amp;4 4&amp;1&amp;5 end{bmatrix}$ . Nullspace of $A$ = all solutions of $x$ where $Ax=0$. Because there are 3 unknowns, it&#39;s a subspace in $R^3$. This is opposed to the column space that is in $R^4$. Naturally the 0 vector always satisfies this so is always in the nullspace. Here&#39;s a few others . $ begin{bmatrix}0 0 0 end{bmatrix}$, $ begin{bmatrix}1 1 -1 end{bmatrix}$, $ begin{bmatrix}2 2 -2 end{bmatrix}$, $ begin{bmatrix}-1 -1 1 end{bmatrix}$, $ begin{bmatrix}-2 -2 2 end{bmatrix}$ . To summarize, we really have a line in $R^3$, which is a subspace: $c begin{bmatrix}1 1 -1 end{bmatrix}$ . Solution Spaces . Great! So we have defined the nullspace, which is just a subspace when $b$ is the 0 vector. Why not do the same thing with other $b$&#39;s? For example: . $Ax=b$ $ begin{bmatrix}1&amp;1&amp;2 2&amp;1&amp;3 3&amp;1&amp;4 4&amp;1&amp;5 end{bmatrix}$ $ begin{bmatrix}x_1 x_2 x_3 end{bmatrix}$ $=$ $ begin{bmatrix}1 2 3 4 end{bmatrix}$ . Clearly it isn&#39;t a space because the zero vector is not a solution. . Possible Solutions = $ begin{bmatrix}1 0 0 end{bmatrix}$, $ begin{bmatrix}2 1 -1 end{bmatrix}$, $ begin{bmatrix}3 2 -2 end{bmatrix}$, $ begin{bmatrix}0 -1 1 end{bmatrix}$ .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/16/18.06_6_ColumnSpace_Nullspace.html",
            "relUrl": "/linear%20algebra/2020/05/16/18.06_6_ColumnSpace_Nullspace.html",
            "date": " • May 16, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Transposes, Permutations, and Spaces (18.06_L5)",
            "content": "Background . In previous posts, we have gone over elimination to solve systems of equations. However, every example workout out perfectly. What I mean by that is we didn&#39;t have to do row exchanges. Every example was in an order that worked on attempt 1. In this post, we are going to talk about how to solve equations when this isn&#39;t the case. . Row Exchanges . The way we do a row exchange in matrix language is that we multiply by a permutation matrix, which we will refer to as $P$. . So how do we account for row exchanges? Our previous equation of $A=LU$ does not account for row exchanges. . Permutations . A Permutation matrix executes our row exhanges. This matrix $P$ is the identify matrix with reording rows. $A=LU$ becomes $PA=LU$. We multipy a permutation matrix $P$ by $A$. . Note: The reason we were able to ignore $P$ in previous posts is because when you have no row exchanges, $P$ is just the identify matrix (no re-ordering) If we were to switch rows 2 and 3 in a 3x3 matrix, $P$ would be . $$ begin{bmatrix}1&amp;0&amp;0 0&amp;0&amp;1 0&amp;1&amp;0 end{bmatrix}$$ . Transposed Matrices . A transposed matrix has rows and columns switched. Naturally, symmetric matrices are unchanged by the transpose. . A Matrix multiplied by it&#39;s transpose always gives a symmetric matrix. . Vector Spaces . To have a vector space you need to be able to: . Add any vectors and still be within the space | Multiply by any number and stay within space | Take any linear combination and stay within space | Examples . $R^2$ is a vector space. This is all real number vectors with 2 components. Here&#39;s a few examples. . $ begin{bmatrix}3 2 end{bmatrix}$, $ begin{bmatrix}0 0 end{bmatrix}$, $ begin{bmatrix} pi e end{bmatrix}$ . $R^3$ is another vector space, but it contains all real 3D vectors. Here&#39;s a few examples. . $ begin{bmatrix}3 2 5 end{bmatrix}$, $ begin{bmatrix}3 2 0 end{bmatrix}$, $ begin{bmatrix}0 0 0 end{bmatrix}$, $ begin{bmatrix} pi e 5 end{bmatrix}$ . $R^n$ is another with all column vectors with $n$ real components. . Subspaces . What if we just want a piece of $R^n$? We still need to be able to add vectors and multiply it together. So what are some subspaces? . A line through $R^n$ that goes through the origin. Any multiple of a point on a line is still on the line. We need the origin because you can mutliply any vector by 0, which would give you the origin. | Just the Origin is a subspace. You can add it to itelf, multiply it by anything, and take any combination and you will stil lhave the origin. | In $R^3$ and above, a plane through the origin is also a subspace. | Subpace from a matrix . $ begin{bmatrix}1&amp;3 2&amp;3 4&amp;1 end{bmatrix}$ . Columns in $R^3$ and all their linear combinations are a subspace. This subspace is a plane going through the origin .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/13/18.06_5_Transposes,Permutations,Spaces.html",
            "relUrl": "/linear%20algebra/2020/05/13/18.06_5_Transposes,Permutations,Spaces.html",
            "date": " • May 13, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Predictive Customer Analytics (Part 2)",
            "content": "Intro . Customer Analytics is a valuable tool, but often the basics are overlooked. It can have a huge impact, and it doesn’t always mean complex modeling. It always starts with the basics. . This is the 2nd post in a series about customer analytics. The first post discusses descriptive analytics and how to create and use descriptive customer analytics. In this post we will be building on that descriptive framework to create a very basic predictive model. A predictive model allows companies to plan proactively instead of reactively. . Background . In the first post we created three descriptive metrics (Recency, Frequency, and Average Monetary Value). Recency is days since the last purchase. Frequency is the number of cycles that the customer purchased product in. Monetary Value is the average revenue brought in from that customer in cycles where the customer purchased product. How can you determine the predicted customer value and take action based on that information? . We need to group customers based on how they behave. This allows us to quickly and efficiently test different actions and see how that affects our long term revenue projections. A customer who makes many small purchases may be just as valuable as a customer who places huge orders infrequently, but they should be handled differently. RFM is one tool we can use to group customers together. . Normalize the metrics . We start with a basic table with three companies and their 3 KPIs. .   Recency (days since previous purchase) Frequency (number of months with purchases) Monetary Value (avg monthly revenue during months with purchases) . Customer A | 3 | 3 | $79 | . Customer B | 35 | 2 | $91 | . Customer C | 48 | 1 | $9852 | . Now that we have values for each of these three metrics (Recency, Frequency, and Monetary Value), we need to put them into a format where we can easily compare the customers. This is called normalizing the data. Normalization puts all the metrics on a scale of 0 (lowest) to 1 (highest). Here is a formula for normalizing: . (&lt;Value you want to normalize&gt; – &lt;Minimum Value in series&gt;) / (&lt;Maximum value in series&gt; – &lt;Minimum value in series&gt;) . Let’s walk through normalizing the Recency KPI. Based on the formula above we need a couple of pieces of information. Let’s identify these now. . Minimum Value in series = 3 Maximum value in series = 48 . Now let’s plug in the formula for each customer to normalize the values. .   Recency Normalized Recency . Customer A | 3 | =(3-3) / (48-3) = 0 | . Customer B | 35 | =(35-3) / (48-3) = 0.711 | . Customer C | 48 | =(48-3) / (48-3) = 1 | . The next step is to repeat this process for the other metrics. I won’t walk through the other two, but here are the accurate values if you’d like to test yourself. .   Recency Frequency Monetary Value . Customer A | 0 | 1 | 0 | . Customer B | 0.711 | 0.5 | 0.001 | . Customer C | 1 | 0 | 1 | . A low recency score is good. A high Frequency or Monetary Value Score is good. If you’d like to simplify it so you don’t have to remember that feel free to take your normalized recency score and subtract it from 1. That will make low scores bad and high scores good on all metrics. . Group the customers together . Now that we have normalized our KPIs, we need to group our customers together. In the table above we only have 3 customers, so there would be no point in grouping them together. In a more practical example we may have 1000 customers, 10,000 customers, or more. When we have that many customers, we can greatly simplify things by grouping like customers together. . We can group customers using our RFM KPIs, but there may be more information we want to pull into that decision. For example if we are a manufacturing company that sells product to end users as well as distributors we may want to take that into account. A distributor is likely to behave and react differently from an individual person. For example, an individual person may get a coupon in the mail and decide to purchase, but a distributor contact may get hundreds of coupons a week and just get annoyed. . A lot of time should be spent exploring different ways to break up customers. Explaining how you break up the customers into groups to sales people, product management, purchasing, production control, and other functional groups in your company can be a great way to get ideas. Each of these groups sees how customers react in different ways and talking to all of them can help give a more complete picture. . Create probability matrix . The goal of customer analytics is to predict how much money we are going to make next month, and the month after, and the month after that, and so on. Once we can predict that with reasonable accuracy we can determine exactly how much revenue we can expect from each customer if we do not change anything. . We need to put probabilities on customer actions. In simplest terms the customer has 2 choices during each cycle, buy or do not buy. So how do we figure out what the chance of that is for a group? . Suppose we a group of distributors we sell to that we believe act similarly as with the table below. A 1 means that the distributor bought something in that cycle, a 0 means that the distributor did not buy anything in that cycle. .   January February March . Distributor A | 1 | 0 | 0 | . Distributor B | 0 | 1 | 0 | . Distributor C | 0 | 1 | 1 | . Since there are 9 total opportunities to buy, and 4 of those have buys in them, we will assign a 4/9 chance of buying. Really this is just another way to measure frequency. . Now we know how many of the customers in the distributor group will buy in a given month (4 out of 9), so we need to turn that into a revenue figure. To do this we will take the sum of revenue from these customers and divide that by the number of buys. Here we are calculating Monetary Value (M), but instead of looking at it on a customer level, we are looking at it for a group of customers. . Once we multiply those two numbers together we have an estimated monthly revenue. . There’s several areas for future improvement that I won’t cover in this post. Depending on the market or the business model your company uses, they will vary in significance. Here’s a few of them: . Take into account recency. | Take into account customer retention. This makes forecasts accuracy go down farther out you go into the future. Since for this application we aren’t looking out very far in the future it makes less of a difference, but it is definitely high priority on our list of future enhancements. | Changes in buy patterns based on seasonal trends. | . Increase revenue using predicted value of each account . Now that we know roughly what revenue we can expect, we can use that for a variety of things. Here’s a few ideas: . First, we can look at which locations/territories are performing as forcasted. Once we know the high performing locations and the low performing locations, we can start to identify what the differences are. This can also be used to manage performance of employees, set meaningful incentives based on revenue, and set measurable objectives. | We can continue to do A/B testing, but be able to tie this to actual revenue dollars. | We can use these forecasts to determine inventory stances on either components or salable goods. | Now that we have grouped customers that behave similarly, we can start to determine how we should treat each group. We can have limited A/B testing. Instead of taking a random group of customers, we can take a random group of distributors to see how they specifically react. | We can determine who our most valuable customers are. Typically without measures, we remember the big purchases. But a regular purchaser that doesn’t make big purchases may be bringing us more revenue. Understanding which customers are most likely to be the most profitable is crucial and can help us determine pricing tiers for customers or determine customer loyalty programs. | We can identify low performing groups and create a strategy to get more penetration into those customers. Maybe for those customers we can send them surveys. Maybe we can set up a forum and do 6 month surveys where we work and collaborate with them regularly. This can help give insight into why they don’t purchase much, as well as be a good sales opportunity. We can also try to take action to take the low performing customers and get them to increase revenue through promotions or other incentives. | We can take the high performing customers and make sure that they know they are appreciated. Whether it’s a can of cashews over the holidays, or having a sales person reach out to talk once a month, building that relationship can really build customer loyalty. | .",
            "url": "https://isaac-flath.github.io/blog/customer%20analytics/2020/05/12/Customer-Analytics-Part-2.html",
            "relUrl": "/customer%20analytics/2020/05/12/Customer-Analytics-Part-2.html",
            "date": " • May 12, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Factorization into $A=LU$ (18.06_L4)",
            "content": "Inverse of $AB$, $A^T$ . Review . So we know from previous lectures/blog posts that $A$ time the inverse of $A$ gives the Identify Matrix $I$. The Identify matrix is matrix equivilent to multiplying by 1, no change to the matrix. . $AA^{-1}=I=A^{-1}A$ . AB Inverse . So if the Inverse of a Matrix time it&#39;s inverse gives the identity, how do we find the inverse of a product of matrices? It turns out you just multiply the inverses of those matrices in reverse. . Why in reverse? If you put socks and shoes on, you wouldn&#39;t invert that process by taking socks off first. You would invert it by doing the steps in reverse. Shoes off first. . A more technical understanding of this can be seen below: . $ABB^{-1}A^{-1}= I$ . Let&#39;s multiply the middle piece first. $BB^{-1}$ We know that equals the Identify matrix, and a matrix time the identity just gives that matrix. So then what you are left wtih is $AA^{-1}=I$, which we also know is true. . This work the other way as well: . $B^{-1}(A^{-1}A)B = I$ . $A^T$ . Transposes work in a similar way. We can tak transposes in reverse to get the Identity Matrix. . $AA^{-1}=I$ . $(A^{-1})^TA^T=I$ . Converting to $A = LU$ . 2x2 to $A=LU$ . Previously we learned that using Elimination we create these Elimination Matrices. In this example of a 2x2 matrix: . $E_{21}A = U =&gt; $ $ left[ begin{array}{cc} 1 &amp; 0 -4 &amp; 1 end{array} right]$ $ left[ begin{array}{cc} 2 &amp; 1 8 &amp; 7 end{array} right]$ $=$ $ left[ begin{array}{cc} 2 &amp; 1 0 &amp; 3 end{array} right]$ . Now how do we get $A=LU$ from this. We can see matrix $A$ and matrix $U$ are already in the right place, so lets leave those alone. We can see that we need to turn Matrix $E_{21}$ into Matrix $L$ by switching it&#39;s sides. The way we move a matrix from one side to the other is through the inverse of the matrix. . $A=LU=&gt;$ $ left[ begin{array}{cc} 2 &amp; 1 8 &amp; 7 end{array} right]$ $=$ $ left[ begin{array}{cc} 1 &amp; 0 4 &amp; 1 end{array} right]$ $ left[ begin{array}{cc} 2 &amp; 1 0 &amp; 3 end{array} right]$ . Note: $E_{21}A = U$ is just a different format of $A=LU$. In $A=LU$ you can see $L$ is just $E_{21}^{-1}$ . 3x3 to $A = LU$ . As we saw in an earlier blog, when we do elimination of a 3x3 matrix we would get more Elmination matrices. We are still working examples with no row exchanges. . $$E_{32}E_{31}E_{21}A=U$$ . So how do we convert this into $A = LU$? As we learned above, we can invert the product of matrices as well. Let&#39;s apply that here with these matrices. . $$A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U$$ . Well that doesn&#39;t look as nice to work with as $A = LU$. So let&#39;s just simplify it by multiplying all the Elimination inverse matrices together. Meaning L would be a product of these 3 inverse matrices. . $$A=E^{-1}U=LU$$ . $A=LU$ vs $EA=U$ . What&#39;s the point of taking the inverse. It&#39;s the same formula mathamatrically, so why bother with this transformation. Why $E^{-1}$ on the right and not just stay with $E$ on the left? Let&#39;s do an example. . $E_{32}E_{21}=E =&gt;$ $ left[ begin{array}{ccc} 1 &amp; 1 &amp; 0 0 &amp; 1 &amp; 0 0 &amp; -5 &amp; 1 end{array} right]$ $ left[ begin{array}{ccc} 1 &amp; 0 &amp; 0 -2 &amp; 1 &amp; 0 0 &amp; 0 &amp; 1 end{array} right]$ $=$ $ left[ begin{array}{ccc} 1 &amp; 0 &amp; 0 -2 &amp; 1 &amp; 0 10 &amp; -5 &amp; 1 end{array} right]$ . $E_{21}^{-1}E_{32}^{-1}=E^{-1} =&gt;$ $ left[ begin{array}{ccc} 1 &amp; 0 &amp; 0 2 &amp; 1 &amp; 0 0 &amp; 0 &amp; 1 end{array} right]$ $ left[ begin{array}{ccc} 1 &amp; 1 &amp; 0 0 &amp; 1 &amp; 0 0 &amp; 5 &amp; 1 end{array} right]$ $=$ $ left[ begin{array}{ccc} 1 &amp; 0 &amp; 0 2 &amp; 1 &amp; 0 0 &amp; 5 &amp; 1 end{array} right]$ . Note: 2 and 5 were the multipliers that we used in our elinimation steps. We can see that with $E^{-1}$ has 2 and 5 in the matrix. So if there are no row exchanges L is just a record of what the multipliers were, which is very convenient. Worded another way, with no row exchanges the multipliers go directly into L. .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/12/18.06_4_Factorization-into-a-lu.html",
            "relUrl": "/linear%20algebra/2020/05/12/18.06_4_Factorization-into-a-lu.html",
            "date": " • May 12, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Random Forest Classifier",
            "content": "Goal . The goal is to predict whether a passenger on the Titanic survived or not. The applications for binary classification are endless and could be applied to many real world problems. Does this patient have this disease? Will this customer Churn? Will price go up? These are just a few examples. . The purpose is to give a general guide to classification. If you get through this and want more detail, I highly recommend checking out the Tabular Chapter of Deep Learning for Coders with fastai &amp; Pytorch by Jeremy Howard and Sylvain Gugger. The book primarily focuses on deep learning, though decision trees are covered for tabular data. All of the material in this guide and more is covered in much greater detail in that book. . https://www.amazon.com/Deep-Learning-Coders-fastai-PyTorch/dp/1492045527 . Setup . We are going to start with loading libraries and datasets that are needed. I am going to skip over this as they are pretty self explanatory, but feel free to look close if you would like. . I am going to use Seaborn to load the Titanic dataset. . #collapse-hide from sklearn.ensemble import RandomForestClassifier import seaborn as sns import pandas as pd import numpy as np from fastai2.tabular.all import * from fastai2 import * from sklearn.model_selection import GridSearchCV from dtreeviz.trees import * from scipy.cluster import hierarchy as hc df = sns.load_dataset(&#39;titanic&#39;) df.head() . . survived pclass sex age sibsp parch fare embarked class who adult_male deck embark_town alive alone . 0 | 0 | 3 | male | 22.0 | 1 | 0 | 7.2500 | S | Third | man | True | NaN | Southampton | no | False | . 1 | 1 | 1 | female | 38.0 | 1 | 0 | 71.2833 | C | First | woman | False | C | Cherbourg | yes | False | . 2 | 1 | 3 | female | 26.0 | 0 | 0 | 7.9250 | S | Third | woman | False | NaN | Southampton | yes | True | . 3 | 1 | 1 | female | 35.0 | 1 | 0 | 53.1000 | S | First | woman | False | C | Southampton | yes | False | . 4 | 0 | 3 | male | 35.0 | 0 | 0 | 8.0500 | S | Third | man | True | NaN | Southampton | no | True | . Data Setup . Dependent Variable . We want to define what we are predicting, or the dependent variable. We also see that &#39;Survived&#39; and &#39;alive&#39; columns are the same thing with different names. We need to get rid of one and predict the other. . # survived is a duplicate of alive, so get rid of it df.drop(&#39;survived&#39;,axis = 1, inplace=True) dep_var = &#39;alive&#39; . Training and Validation Set Split . Best practice is to minimally have a training and validation set. Those are the 2 that we will use for this tutorial. . Training Set: This is what the model actually trains on | Validation Set: This is used to gauge success of the Training | Test Set: This is a held out of the total process to be an additional safeguard against overfitting | . cond = np.random.rand(len(df))&gt;.2 train = np.where(cond)[0] valid = np.where(~cond)[0] splits = (list(train),list(valid)) . Dates . We don&#39;t have any dates to deal with, but if we did we would do the following: . df = add_datepart(df,&#39;date&#39;) . This would replace that date with a ton of different columns, such as the year, the day number, the day of the week, is it month end, is it month start, and more. . Categorical Variables . Ordinal Categorical Variables . Some categorical variables have a natural heirarchy. By telling pandas the order it tends to mean trees don&#39;t have to split as many times, which speeds up training times. . df[&#39;class&#39;].unique() . [Third, First, Second] Categories (3, object): [Third, First, Second] . classes = &#39;First&#39;,&#39;Second&#39;,&#39;Third&#39; . df[&#39;class&#39;] = df[&#39;class&#39;].astype(&#39;category&#39;) df[&#39;class&#39;].cat.set_categories(classes, ordered=True, inplace=True) . Categorical Variables Final . We are now going to do some data cleaning. The Categorify and FillMissing functions in the fastai2 library make this easy. . procs = [Categorify, FillMissing] . cont,cat = cont_cat_split(df, 1, dep_var=dep_var) . to = TabularPandas(df, procs, cat, cont, y_names=dep_var, splits=splits) . Let&#39;s take a look at the training and validation sets and make sure we have a good split of each. . len(to.train),len(to.valid) . (713, 178) . We can now take a look and see that while we see all the same data, behind the scenes it is all numeric. This is exactly what we need for our random forest. . to.show(3) . sex embarked class who adult_male deck embark_town alone age_na pclass age sibsp parch fare alive . 0 male | S | Third | man | True | #na# | Southampton | False | False | 3.0 | 22.0 | 1.0 | 0.0 | 7.250000 | no | . 3 female | S | First | woman | False | C | Southampton | False | False | 1.0 | 35.0 | 1.0 | 0.0 | 53.099998 | yes | . 4 male | S | Third | man | True | #na# | Southampton | True | False | 3.0 | 35.0 | 0.0 | 0.0 | 8.050000 | no | . to.items.head(3) . pclass sex age sibsp parch fare embarked class who adult_male deck embark_town alive alone age_na . 0 | 3.0 | 2 | 22.0 | 1.0 | 0.0 | 7.250000 | 3 | 3 | 2 | 2 | 0 | 3 | 0 | 1 | 1 | . 3 | 1.0 | 1 | 35.0 | 1.0 | 0.0 | 53.099998 | 3 | 1 | 3 | 1 | 3 | 3 | 1 | 1 | 1 | . 4 | 3.0 | 2 | 35.0 | 0.0 | 0.0 | 8.050000 | 3 | 3 | 2 | 2 | 0 | 3 | 0 | 2 | 1 | . Final Change . Finally, we will put just the data in xs and ys so they are in easy format to pass to models. . xs,y = to.train.xs,to.train.y valid_xs,valid_y = to.valid.xs,to.valid.y . Random Forest Model . Initial Model . Let&#39;s start by creating a model without tuning and see how it does . m = RandomForestClassifier(n_estimators=100) m = m.fit(xs,y) . from sklearn.metrics import confusion_matrix . confusion_matrix(y,m.predict(xs)) . array([[445, 1], [ 5, 262]]) . Looking pretty good! Only 6 wrong. Let&#39;s see how it did on the validation set. . confusion_matrix(valid_y,m.predict(valid_xs)) . array([[89, 14], [26, 49]]) . Still way better than 50/50, but not quite as good. This is because the model did not train based on this validation data so it doesn&#39;t perform nearly as well. . Model Tuning - Grid Search . We made our first model, and it doesn&#39;t seem to predict as well as we would like. Let&#39;s do something about that. . We are going to do a grid search. There are many more sophisticated ways to find parameters (maybe a future post), but the grid search is easy to understand. Basically you pick some ranges, and you try them all to see what works best. . We will use the built in gridsearch. All we need to do is define the range of parameters, and let it find the best model. . parameters = {&#39;n_estimators&#39;:range(10,20,20), &#39;max_depth&#39;:range(10,20,20), &#39;min_samples_split&#39;:range(2,20,1), &#39;max_features&#39;:[&#39;auto&#39;,&#39;log2&#39;]} . clf = GridSearchCV(RandomForestClassifier(), parameters, n_jobs=-1) . clf.fit(xs,y) . GridSearchCV(cv=&#39;warn&#39;, error_score=&#39;raise-deprecating&#39;, estimator=RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=&#39;warn&#39;, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False), iid=&#39;warn&#39;, n_jobs=-1, param_grid={&#39;max_depth&#39;: range(10, 20, 20), &#39;max_features&#39;: [&#39;auto&#39;, &#39;log2&#39;], &#39;min_samples_split&#39;: range(2, 20), &#39;n_estimators&#39;: range(10, 20, 20)}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=None, verbose=0) . Results . We can see below that the best esimator works better for prediciton the validation set than the model above did. Success! . confusion_matrix(y,clf.best_estimator_.predict(xs)) . array([[431, 15], [ 43, 224]]) . confusion_matrix(valid_y,clf.best_estimator_.predict(valid_xs)) . array([[95, 8], [25, 50]]) . Model Minimizing . Now that we have good results with a tuned model, we may want to simplify the model. If we can simplify the model without significantly impacting accuracy, that&#39;s good for many reasons. . The model is easier to understand | Fewer variables means fewer data quality issues and more focused data quality efforts | It takes less resources and time to run | Feature Importance . There are many ways to measure importance. How often do we use a feature to split? How high up in the tree is it used to split? We are going to use scikit learns feature importance information. . Let&#39;s look at what features are! . #collapse def rf_feat_importance(m, df): return pd.DataFrame({&#39;cols&#39;:df.columns, &#39;imp&#39;:m.feature_importances_} ).sort_values(&#39;imp&#39;, ascending=False) . . fi = rf_feat_importance(m, xs) fi[:5] . cols imp . 13 | fare | 0.205103 | . 10 | age | 0.198317 | . 4 | adult_male | 0.104956 | . 0 | sex | 0.097934 | . 3 | who | 0.094934 | . Alright so we see that the most important variable is how much the passenger paid for their fare. Lovely. . def plot_fi(fi): return fi.plot(&#39;cols&#39;, &#39;imp&#39;, &#39;barh&#39;, figsize=(12,7), legend=False) plot_fi(fi[:30]); . Remove Low Important Variables . This isn&#39;t strictly neccesarry, but it is nice to simplify models if you can. Simpler models are easier to understand and maintain, and they take less resources to run. It is also interesting to know just how many variables are needed to predict. . to_keep = fi[fi.imp&gt;0.045].cols len(to_keep) . 8 . xs_imp = xs[to_keep] valid_xs_imp = valid_xs[to_keep] . clf = GridSearchCV(RandomForestClassifier(), parameters, n_jobs=-1) clf.fit(xs_imp,y) . GridSearchCV(cv=&#39;warn&#39;, error_score=&#39;raise-deprecating&#39;, estimator=RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=&#39;warn&#39;, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False), iid=&#39;warn&#39;, n_jobs=-1, param_grid={&#39;max_depth&#39;: range(10, 20, 20), &#39;max_features&#39;: [&#39;auto&#39;, &#39;log2&#39;], &#39;min_samples_split&#39;: range(2, 20), &#39;n_estimators&#39;: range(10, 20, 20)}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=None, verbose=0) . Results . Now we see with only 8 features we still get pretty good results on on validation set. . Now the question is whether this small loss in accuracy outweighed by a simpler and more efficient model? That is a business question more than it is a data science question. . If you are detecting COVID-19, you probably want it to be as accurate as possible. If you are going to predict whether someone is a cat or a dog person based on a survey for marketing purposes, small changes in accuracy probably are not as critical. . confusion_matrix(y,clf.best_estimator_.predict(xs_imp)) . array([[422, 24], [ 62, 205]]) . confusion_matrix(valid_y,clf.best_estimator_.predict(valid_xs_imp)) . array([[98, 5], [24, 51]]) . clf.best_estimator_ . RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;, max_depth=10, max_features=&#39;auto&#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=14, min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) . Redundant columns . Of the 6 remaining variables, we can see that some of them are very related. It makes sense to me that deck and fare are related. Nicer areas probably cost more. It makes sense to me that the person&#39;s sex has some redudancy with adult_male - the redundancy is even in the name. . #collapse def cluster_columns(df, figsize=(10,6), font_size=12): corr = np.round(scipy.stats.spearmanr(df).correlation, 4) corr_condensed = hc.distance.squareform(1-corr) z = hc.linkage(corr_condensed, method=&#39;average&#39;) fig = plt.figure(figsize=figsize) hc.dendrogram(z, labels=df.columns, orientation=&#39;left&#39;, leaf_font_size=font_size) plt.show() . . cluster_columns(xs_imp) . Now from the chart above, we can clearly see that class and pclass are completely redundant. We see the sex and adult_male has some redundancy as well. This makes sense as part of the adult_male column is the sex. Let&#39;s go ahead and drop one of the class or pclass variables (they are redundant so doesn&#39;t matter which). . xs_imp = xs_imp.drop(&#39;pclass&#39;, axis=1) valid_xs_imp = valid_xs_imp.drop(&#39;pclass&#39;, axis=1) . xs_imp.head() . fare age adult_male sex who deck class . 0 | 7.250000 | 22.0 | 2 | 2 | 2 | 0 | 3 | . 3 | 53.099998 | 35.0 | 1 | 1 | 3 | 3 | 1 | . 4 | 8.050000 | 35.0 | 2 | 2 | 2 | 0 | 3 | . 5 | 8.458300 | 28.0 | 2 | 2 | 2 | 0 | 3 | . 6 | 51.862499 | 54.0 | 2 | 2 | 2 | 5 | 1 | . clf.fit(xs_imp,y) . GridSearchCV(cv=&#39;warn&#39;, error_score=&#39;raise-deprecating&#39;, estimator=RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=&#39;warn&#39;, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False), iid=&#39;warn&#39;, n_jobs=-1, param_grid={&#39;max_depth&#39;: range(10, 20, 20), &#39;max_features&#39;: [&#39;auto&#39;, &#39;log2&#39;], &#39;min_samples_split&#39;: range(2, 20), &#39;n_estimators&#39;: range(10, 20, 20)}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=None, verbose=0) . Ok, so now on to variables that are not completely redundant. Let&#39;s experiment with removing some columns and see what we get. We will use accuracy for our metric. . Here is out baseline: . #collapse print(&quot;accuracy: &quot;) (confusion_matrix(valid_y,clf.best_estimator_.predict(valid_xs_imp))[0,0] + confusion_matrix(valid_y,clf.best_estimator_.predict(valid_xs_imp))[1,1] )/ confusion_matrix(valid_y,clf.best_estimator_.predict(valid_xs_imp)).sum() . . accuracy: . 0.8258426966292135 . #collapse def get_accuracy(x,y,valid_x,valid_y): m = RandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;, max_depth=10, max_features=&#39;auto&#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=4, min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) m.fit(xs_imp,y) print((confusion_matrix(valid_y,m.predict(valid_xs_imp))[0,0] + confusion_matrix(valid_y,m.predict(valid_xs_imp))[1,1] )/ confusion_matrix(valid_y,m.predict(valid_xs_imp)).sum()) . . We will now loop through each of the remaining variables and train a model and print out the accuracy score. . Judging by the scores below, removing any 1 variable does not significantly reduce the accuracy. This means that we have redundant columns that can likely be trimmed. Sex seems to be a column we would definitely keep as removing it have the most impact on accuracy. . From this we can remove variables and iterate through to continue simplifying as much as possible. . #collapse variables = list(xs_imp.columns) for variable in variables: print(&#39;drop &#39;+variable+&#39; accuracy:&#39;) get_accuracy(xs_imp.drop(variable, axis=1), y, valid_xs_imp.drop(variable, axis=1), valid_y) . . drop fare accuracy: 0.8539325842696629 drop age accuracy: 0.8258426966292135 drop adult_male accuracy: 0.8370786516853933 drop sex accuracy: 0.8258426966292135 drop who accuracy: 0.8314606741573034 drop deck accuracy: 0.8146067415730337 drop class accuracy: 0.8258426966292135 .",
            "url": "https://isaac-flath.github.io/blog/tree%20ensembles/2020/05/11/RandomForestClassifier.html",
            "relUrl": "/tree%20ensembles/2020/05/11/RandomForestClassifier.html",
            "date": " • May 11, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Multiplication and Inverse Matrices (18.06_L3)",
            "content": "Matrix Multiplication . Rules . A matrix is laid out by row and column. Menaing, a particular cell in matrix $C$ is $C_{ij}$. For example, $C_{34}$ is the 3rd row, 4th column in matrix $C$. . $ begin{bmatrix} 1,1&amp;1,2&amp;1,3&amp;1,4 2,1&amp;2,2&amp;2,3&amp;2,4 3,1&amp;3,2&amp;3,3&amp;3,4 4,1&amp;4,2&amp;4,3&amp;4,4 end{bmatrix}$ . Number of columns in matrix A must match number of rows in matrix B. | The output of matrix multiplication will be dimensions equal to the number of rows in matrix A by the number of columns in matrix B. | You can cut the matrix into blocks and do matrix multiplication in blocks. | $ begin{bmatrix}A_1&amp;A_2 A_3&amp;A_4 end{bmatrix} begin{bmatrix}B_1&amp;B_2 B_3&amp;B_4 end{bmatrix}= begin{bmatrix}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4 A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4 end{bmatrix}$ . Note: While cutting it into blocks may not seem useful immediately, it is crucial for high speed computation. In Deep Learning where you are multiplying large matrices together can speed up computation speed immensely by breaking them into blocks so you can fit the blocks into CPU Memory. In fact, this is exactly what pytorch does. . 1st Way . Let&#39;s imagine we have a matrix multiplation . $$AB=C$$ . $C_{34}=$(row 3 of A)$ cdot$(column 4 of B) . $C_{34}=a_{31}b_{14}+a_{32}b_{24}+......$ . $C_{34}= sum limits_{k=1}^n a_{3k}b_{k4}$ . 2nd Way . $$AB=C$$ . The second way to think about it is that matrix $A$ times by the first column of matrix $B$ will give you the first column of $C$. . Matrix $A$ times by the second column of matrix $B$ will give you the second column of $C$. . Now really what we are doing is thinking of columns of $C$ as combinations of columns of $A$ . $A cdot B_{n1} =C_{m1}$ . 3rd Way . $$AB=C$$ . The third way to think about it is that a row of $A$ times matrix $B$ will give you a column of $C$. . Now really what we are doing is thinking of rows of $C$ as combinations of rows of $B$. . 4th Way . If we multiply a column by a row, we get a full sized matrix. We also see that the columns are multiples of the column, and the rows and multiples of the row. This is what we expect as we just discussed above with the combinations of each other. . $ begin{bmatrix}2 3 4 end{bmatrix} begin{bmatrix}1&amp;6 end{bmatrix}= begin{bmatrix}2&amp;12 3&amp;18 4&amp;24 end{bmatrix}$ . $AB=$Sum of (Cols of A) $ cdot$ (Rows of B) . $ begin{bmatrix}2&amp;7 3&amp;8 4&amp;9 end{bmatrix} begin{bmatrix}1&amp;6 0&amp;0 end{bmatrix}$ $=$ $ begin{bmatrix}2 3 4 end{bmatrix} begin{bmatrix}1&amp;6 end{bmatrix}+$ $ begin{bmatrix}7 8 9 end{bmatrix} begin{bmatrix}0&amp;0 end{bmatrix}$ $=$ $ begin{bmatrix}2&amp;12 3&amp;18 4&amp;24 end{bmatrix}$ . This matrix all sit on the same line because they are just multiples. . Inverses . Not all Matrices have inverses. Most important question is whether it&#39;s invertable. If $A^-1$ exists. . $A^{-1}A = I = AA^{-1}$ . Invertable, nonsingular are the good case. . Matrices with no inverse . In the singular case there is no inverse. 2x2 matrix that has no inverse. . $ begin{bmatrix}1&amp;3 2&amp;6 end{bmatrix}$ . Cannot get 1,0, because I can find a vector $x$ with $Ax=0$ . $ begin{bmatrix}1&amp;3 2&amp;6 end{bmatrix} begin{bmatrix}3 -1 end{bmatrix}= begin{bmatrix}0 0 end{bmatrix}$ . But why does this matter? Because if I use these values for X anything I multiply by cannot possibly give the identify matrix, because 0 times anything gives 0. . Matrices with an inverse . $AA^{-1}=I =&gt; begin{bmatrix}1&amp;3 2&amp;7 end{bmatrix} begin{bmatrix}a&amp;b c&amp;d end{bmatrix}= begin{bmatrix}1&amp;0 0&amp;1 end{bmatrix}$ . Now from our matrix multiplication work above we know that $A cdot$column $j$ of $A^{-1} = $column $j$ of $I$ . So we really have a system of 2 equations to solve. . $ begin{bmatrix}1&amp;3 2&amp;7 end{bmatrix} begin{bmatrix}a c end{bmatrix}= begin{bmatrix}1 0 end{bmatrix}$ . $ begin{bmatrix}1&amp;3 2&amp;7 end{bmatrix} begin{bmatrix}b d end{bmatrix}= begin{bmatrix}0 1 end{bmatrix}$ . So we are back to solving systems of equations. . Gauss-Jordan / Find $A^{-1}$ . Solve 2 equations at once . $ begin{bmatrix}1&amp;3 2&amp;7 end{bmatrix} begin{bmatrix}a b end{bmatrix}= begin{bmatrix}1 0 end{bmatrix}$ . $ begin{bmatrix}1&amp;3 2&amp;7 end{bmatrix} begin{bmatrix}c d end{bmatrix}= begin{bmatrix}0 1 end{bmatrix}$ . The gauss-Jordan Method solved both equations at once by created an augmented matrix. . We will now do elimination steps to get the identify on the left. This will convert A to A inverse. . Start with $AI$ | Elimination step subtracting 2 of the first row from the second row | Elinination step subtracting 3 of the second row from the first. | End with $IA^{-1}$ | $ left[ begin{array}{cc|cc} 1 &amp; 3 &amp; 1 &amp; 0 2 &amp; 7 &amp; 0 &amp; 1 end{array} right] =&gt; left[ begin{array}{cc|cc} 1 &amp; 3 &amp; 1 &amp; 0 0 &amp; 1 &amp; -2 &amp; 1 end{array} right] =&gt; left[ begin{array}{cc|cc} 1 &amp; 0 &amp; 7 &amp; -3 0 &amp; 1 &amp; -2 &amp; 1 end{array} right] $ . Naturally we get the inverse because we really reverse the sides of the equation. Just like in algebra if you have -5 on one side, you can move it by putting the inverse on the other side (+5). .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/11/18.06_3_Multiplication-and-Inverse-Matrices.html",
            "relUrl": "/linear%20algebra/2020/05/11/18.06_3_Multiplication-and-Inverse-Matrices.html",
            "date": " • May 11, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Descriptive Customer Analytics (Part 1)",
            "content": "Intro . Customer Analytics is a valuable tool, but often the basics are overlooked. It can have a huge impact, and it doesn’t always mean complex modeling. It always starts with the basics. Because customer analytics can make such a big impact, I am going to break this into several posts. . In this post (Part 1) I am going to explain a basic descriptive customer analytics framework and how use it to identify the current state.  This understanding allows us to conduct A/B testing so we can measure how our actions impact revenue and by how much. There are many ways to do this, this is just one of them. . In Part 2 I’ll talk about how to build on the descriptive framework to create a predictive model.  A predictive model allows companies to plan proactively instead of reactively. . Background: . Many companies rely on experience and basic summarizing of historical statistics to make decisions.  While both of these are useful tools, a powerful way to successfully sustain long term revenue growth is to add customer analytics to their tool belt.  In this post I am discussing the starting point for analytics, descriptive analytics. . An easy and solid starting point for descriptive analytics is a RFM (Recency, Frequency, Monetary Value) model.  A primary advantage to this is the only data you need is purchase history for each customer, which is information that almost every company tracks.  I’ve outlined the three main steps to creating this framework and using it to increase revenue. . Determine length of customer buying cycle: . The first step is to determine what time range is a good time range to use for a buying cycle.  For a grocery store, maybe we say typically people go grocery shopping once a week.  In that scenario we would use 1 week as our time range for our cycle.  However a company that prints business cards may find a much longer time frame as customers tend to buy 1,000 and repurchase when they get low.  For this example we could use a 6 month cycle.  I encourage people to explore their data and pick a time range based on intuition.  There are better and more complicated ways to figure out this time range, but I encourage people to demonstrate results and revenue growth before circling back with more resources and support from executive management. . Calculate descriptive customer metrics: . Let’s say we choose a 1 month cycle.  The next step is to create and fill in a table to get frequency and monetary Value.  In the table below I outline how we calculate both of those KPIs (Key Performance Indicators). .   January February March Frequency Monetary Value . Example | Rev | Rev | Rev | # of slots purchased in | Average Monetary Value | . Customer A | $102 | $60 | $75 | 3 | =($102+$60+$75) / 3 | . Customer B | $97 | $85 | $0 | 2 | =($85+97) / 2 | . Customer C | $0 | $9852 | $0 | 1 | =($9,852) / 1 | . Once this is done add another column for Recency and fill that in with how long since that last purchase.  This can be days, hours, or seconds since last purchase depending on how far apart customer purchases typically are.  For this simplified version we will use days.  We end up with a table like this: .   Recency Frequency Monetary Value . Customer A | 3 | 3 | $79 | . Customer B | 35 | 2 | $91 | . Customer C | 48 | 1 | $9852 | . Conduct A/B testing: . Now that we have three metrics (RFM) that describe customer buying patterns, we can start using them to run experiments to drive revenue growth.  A/B testing is a simple experiment that you can run to compare two things. You split your customers into two group and make no change to what you are doing to group A, but do something different in group B.  By doing this we can compare the revenue of the two groups to see what impact our efforts had.  If B is better, we will apply that action to the entire customer base.  If not, we scrap the idea and move on.  This is a never-ending process of  testing new ideas. . Here’s a few ideas for A/B tests using RFM to get you started: . Call every customer in group B to see how that impacts revenue.  Does this increase Frequency (F) or average Monetary Value (M) of orders?  Is it worth the additional resources? | Send a marketing email blast to everyone in group B.  How does this change group B’s buying patterns? | What impact does sending a one-time-only 5 % off coupon have? | If we raise the price by 5 % in group B, what is the effect on revenue?  This is especially useful because we can run limited experiments and gauge reaction of price hikes without angering every customer. | If we raise the price on a product that is nearing the end of its product life cycle, do sales increase on the newly released product?  Does a price hike on old products encourage customers to buy newer versions? | Send group A customers to the current website and group B customers to a new website layout.  Monitor sales, traffic, and clicks on each site.  This can help determine the better layout. | .",
            "url": "https://isaac-flath.github.io/blog/customer%20analytics/2020/05/10/Customer-Analytics-Part-1.html",
            "relUrl": "/customer%20analytics/2020/05/10/Customer-Analytics-Part-1.html",
            "date": " • May 10, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Elimination with Matrices (18.06_L2)",
            "content": "Motivation . One of my goals is to understand more deeply what Neural Networks are doing. Another is to have an easier time understanding and implementing cutting edge academic papers. In order to work toward those goals, I am revisiting the Math behind Neural Networks. This time my goal is to understand intuitively every piece of the material forward and backward - rather than to pass a course on a deadline. . This blog post will be my notes about Lecture 2 from the following course: . Gilbert Strang. 18.06 Linear Algebra. Spring 2010. Massachusetts Institute of Technology: MIT OpenCourseWare, https://ocw.mit.edu. License: Creative Commons BY-NC-SA. . Goal . The goal is to solve N equations with N unknowns, just like it was with lecture 1. In the first Lecture it was about understanding how to solve them intuitively with linear combinations and matrix multiplication. In reality, that is not a scalable choice when you get to higher and higher dimensions. We need to be able to express these concepts in matrices and be more comfortable with that language and operations.. . Matrix Form . As a recap, we can express a system of equations by listing the equations. x . $x+2y+z=2$ . $3x+8y+z=12$ . $4y+z=2$ . We can write the same thing in matrix form using the formula $Ax=b$. The matrix A is from the system of equation above. . $A = begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix}$ . Elimination . The general idea in elimination is to isolate variables so we can solve the equation. For example, if we have 0x + 0y + 1z = 10, it is very easy to solve for z. We can then plug it into another equation in the series that has z and 1 other unknown to get another value, and so on and so forth. . $E_{21}$ . We are going to start by eliminating the first variable in the second row. Row 2, column 1. This would leave the second row with only 2 unknowns. . The way we do this is we subtract row 1 from row 2. If we substract 3 * 1 from 3, we get 0, so 3 will be the multiplier. . $ begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 0&amp;0&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix} = begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;4&amp;1 end{bmatrix}$ . $E_{31}$ . We then move on to row 3, column 1. Lucky for us it&#39;s already 0 so we can skip this step . $E_{32}$ . We now move on to row 3, column 2. If we can get this to 0, then we have 1 unknown in that column. That&#39;s what we want as that&#39;s easily solvable. . $ begin{bmatrix}1&amp;0&amp;0 0&amp;1&amp;0 0&amp;-2&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;4&amp;1 end{bmatrix} = begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix}$ . How can this fail? . A 0 cannot be in one of the pivot spots. The pivot positions are the diagonals. If that happens, elimination will fail. If you think about it, a 0 being in the pivot spot means that the left side of the equation is 0. Either the right side is also 0 and it gives you no information, or the right side is not 0 and there is no solution (ie 2 = 0 is False). . Of course, there are some tricks that can be added to minimize failures. The most common of these are row exchanges. By swapping the order of the rows, you can potentially solve an equation that would have failed in the original order. . For example, if I were to exchange the 2nd and 3rd rows I would multiply by the following matrix. . $ begin{bmatrix}1&amp;0&amp;0 0&amp;0&amp;1 0&amp;1&amp;0 end{bmatrix}$ . Back Substitution . Let&#39;s recap the steps that were taken. We started with A and through elimination in 2 steps we ended with a new matrix. . $A =&gt; begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix} =&gt; begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;4&amp;1 end{bmatrix} =&gt; begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix} =&gt; U$ . Finish the Equation . You may have realized these matrices represented the left side of the equation. You may have wondered how we can modify the left side of the equation while leaving the right side alone? The answer is that we cannot. What is done on the left side must be applied to the right side. Let&#39;s do that now. . We have done 2 transformations. . The first transformation was subtracting 3 of the first row from the second. | The second transformation was subracting 2 of the second row from the third. | Let&#39;s do that to the the right side . b =&gt; $ begin{bmatrix}2 12 2 end{bmatrix} =&gt; begin{bmatrix}2 6 2 end{bmatrix} =&gt; begin{bmatrix}2 6 -10 end{bmatrix} =&gt; c$ . Let&#39;s put the left and right side of the equations together to see what it looks like. . $Ux = C$ . $ begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix} begin{bmatrix}x y z end{bmatrix}= begin{bmatrix}2 6 -10 end{bmatrix}$ . Final Solution . Intuitive Solution . Great! Let&#39;s translate the $Ux=C$ matrix above back to our systems of equations view just to see if we can see how this transformation helps us. . $x + 2y + z = 2$ . $2y - 2z = 6$ . $5z = -10$ . When we look at it here, we can solve them with some simple algebra starting from the bottom equation. . $5z = -10 ; ; ; mathbf{=&gt;} ; ; ; z = -10/5 ; ; ; mathbf{=&gt;} ; ; ; z = -2$ . $2y - 2z = 6 ; ; ; mathbf{=&gt;} ; ; ; 2y - 2(-2) = 6 ; ; ; mathbf{=&gt;} ; ; ; 2y + 4 = 6 ; ; ; mathbf{=&gt;} ; ; ; 2y = 2 ; ; ; mathbf{=&gt;} ; ; ; y = 1$ . $x+2y+z=2 ; ; ; mathbf{=&gt;} ; ; ;x+2-2=2$$x+2y+z=2 ; ; ; mathbf{=&gt;} ; ; ;x=2$ . Matrix Solution . So first we should ask if we have an intuitive solution, why bother with doing the whole thing in matrix format? Isn&#39;t it the same thing? . And yes, we will be doing the same thing. The reason is scalability and ability to transfer to N equation and N unknowns. There&#39;s a limit to what can be done by hand, and matrix form allows for easier scalability. . Recap . We did several steps intuitively. Let&#39;s recap our elimination steps from above . $E_{21}$ step $ begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 0&amp;0&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix} = begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;4&amp;1 end{bmatrix}$ . $E_{32}$ step $ begin{bmatrix}1&amp;0&amp;0 0&amp;1&amp;0 0&amp;-2&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;4&amp;1 end{bmatrix} = begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix}$ . Simplify into 1 step . Great! Now let&#39;s just combine these so we only have 1 equation. . $E_{21}E_{32}A=U$ $ begin{bmatrix}1&amp;0&amp;0 0&amp;1&amp;0 0&amp;-2&amp;1 end{bmatrix} begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 0&amp;0&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix}= begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix} $ . Now let&#39;s simplify this by multiplying and combining my $E_{21}$ and $E_{31}$ matrices together. We will call the result $E$ . $E_{21}E_{32}=E$ $ begin{bmatrix}1&amp;0&amp;0 0&amp;1&amp;0 0&amp;-2&amp;1 end{bmatrix} begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 0&amp;0&amp;1 end{bmatrix} = begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 6&amp;-2&amp;1 end{bmatrix}$ . Great! Now we can use this to simplify our formula. . $EA=U$ $ begin{bmatrix}1&amp;0&amp;0 -3&amp;1&amp;0 6&amp;-2&amp;1 end{bmatrix} begin{bmatrix}1&amp;2&amp;1 3&amp;8&amp;1 0&amp;4&amp;1 end{bmatrix}= begin{bmatrix}1&amp;2&amp;1 0&amp;2&amp;-2 0&amp;0&amp;5 end{bmatrix}$ .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/10/18.06_2_EliminationWithMatrices.html",
            "relUrl": "/linear%20algebra/2020/05/10/18.06_2_EliminationWithMatrices.html",
            "date": " • May 10, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "Gradient Descent for Linear Regression",
            "content": "The goal of linear regression is to find parameter values that fit a linear function to data points.  The goodness of fit is measured by a cost function.  The lower the cost, the better the model.  Gradient Descent is a method to minimize a cost function.  Gradient descent is a widely used tool and is used frequently in tuning predictive models.  It’s important to understand the method so you can apply it to various models and are not limited to using black box models. . As I just mentioned, gradient descent is a method to reduce a cost function.  To understand how to minimize a cost function, you need to understand how cost is calculated.  For this post I will be using a very simple example; linear regression with one feature, two data points, and two regression coefficients.  I will use the sum of squares cost function to take the predicted line and slowly change the regression coefficients until the line passes through both points. . . In this example we could easily draw a line through the points without using gradient descent, but if we had more data points this would get trickier.  In the table below we can see what the data looks like that we are working with. . . The tree below illustrates how to solve for cost as well as how to improve the values of $ theta$ to minimize cost.  In the illustration above, $J = a^1 + a^2$ is the cost function we want to minimize.  As we can see, if the regression coefficients ($ theta_0+ theta_1$) do not give a good fit, then the difference between our predicted values and observed values will be large and we will have a high cost ($J$).  For low values, we will have a low cost ($J$).  The figure below shows us how to calculate cost from the regression coefficients ($ theta_0$ and $ theta_1$). . . The second thing this chart shows you is how to improve values of theta.  We used the formulas in the boxes to evaluate $J$, so now we will use the values on the edges to improve the parameter values.  Each regression coefficient has a path up to the cost function.  You get a path value for each $ theta$ on the tree by multiplying the edge values along that path.  For example: . $ theta_1 ; path ;value = x^1 (y^1_{pred} - y^1_{obs}) (1) + x^2 (y^2_{pred} - y^2_{obs}) (1)$ . The last step is to improve the value of $ theta$.  In order to improve the value of $ theta$, we need to multiply the path value by $ alpha$, and subtract that from that $ theta$.  $ alpha$ is a value that determines how large the increments will be taken during optimization.  If you pick an $ alpha$ value that is is too large, you risk missing the local optima.  If you choose an $ alpha$ value that is too small you will be very accurate, but it will be more computationally expensive. With more data points there would be more edges originating at $J$, and with more features there would be more thetas originating from the predicted values, but the same concept can be applied to these more complicated examples. .",
            "url": "https://isaac-flath.github.io/blog/gradient%20descent/2020/05/09/GradientDescentforLinearRegression-P1.html",
            "relUrl": "/gradient%20descent/2020/05/09/GradientDescentforLinearRegression-P1.html",
            "date": " • May 9, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "Geometry of Linear Equations (18.06_L1)",
            "content": "#collapse-hide import matplotlib.pyplot as plt from torch import tensor from torch import solve import numpy as np from mpl_toolkits import mplot3d from mpl_toolkits.mplot3d import Axes3D . . Motivation . One of my goals is to understand more deeply what Neural Networks are doing. Another is to have an easier time understanding and implementing cutting edge academic papers. In order to work toward those goals, I am revisiting the Math behind Neural Networks. This time my goal is to understand intuitively every piece of the material forward and backward - rather than to pass a course on a deadline. . This blog post will be my notes about Lecture 1 from the following course: . Gilbert Strang. 18.06 Linear Algebra. Spring 2010. Massachusetts Institute of Technology: MIT OpenCourseWare, https://ocw.mit.edu. License: Creative Commons BY-NC-SA. . Goal . The goal is to solve N equations with N unknowns. We will start with 2 equations with 2 unknowns, then go to 3 equations with 3 unknowns. We will use an intuitive approach here to understand a bit about how linear equations work. . How do we multiply these together? . Matrix Multiplication (Ax=b) . $ begin{bmatrix} 2 &amp; 5 1 &amp; 3 end{bmatrix}$ $ begin{bmatrix} 1 2 end{bmatrix}$ $=1$ $ begin{bmatrix} 2 1 end{bmatrix}$ $+2$ $ begin{bmatrix} 5 3 end{bmatrix}$ $=$ $ begin{bmatrix} 12 7 end{bmatrix}$ . Ax is a linear combination of columns . 2 equations 2 unknowns . Ok, Let&#39;s look at a couple equations in a few different ways. The solution to these are any values of x and y that make both equations true. . $2x - y = 0$ . $-x + 2y = 3$ . Row Picture . We can take these 2 linear equations and plot them. . $2x - y = 0$ could be writen as $y = 2x$, which is trivial to graph. If we graph them both, we can see visually where they are both true (the intersection). . def plot_equations_2d(x_range,y_dict): for y in y_dict: plt.plot(x, y_dict[y], label=y) plt.xlabel(&#39;x&#39;, color=&#39;#1C2833&#39;) plt.ylabel(&#39;y&#39;, color=&#39;#1C2833&#39;) plt.legend(loc=&#39;upper left&#39;) plt.grid() plt.show() x = tensor(np.linspace(-4,4,100)) y_dict = {&#39;2x-y=0&#39;:2*x, &#39;-x+2y=3&#39;:(3 + x)/2} plot_equations_2d(x,y_dict) . Column Picture . We can rewrite out equations into a different notation, which gives us a more concise view of what is going on. You can see that the top row is the first equation, and the bottom row is the second. Same thing, written differently. . $x$ $ begin{bmatrix} 2 -1 end{bmatrix}$ $+y$ $ begin{bmatrix} -1 2 end{bmatrix}$ $=$ $ begin{bmatrix} 0 3 end{bmatrix}$ . Graphed as Vectors . Now that we see them it in column form, we can graph the vectors . #collapse-hide strt_pts = tensor([[0,0],[2,-1]]) end_pts = tensor([[2,-1],[1,2]]) diff = end_pts - strt_pts plt.ylim([-3, 3]) plt.xlim([-3, 3]) plt.quiver(strt_pts[:,0], strt_pts[:,1], diff[:,0], diff[:,1], angles=&#39;xy&#39;, scale_units=&#39;xy&#39;, scale=1.) plt.show() . . Summed as Vectors . Now that they are represented as vectors. Let&#39;s add 1X + 2Y vectors and see that we get (0,3). Simply make one vector start where the other ends . #collapse-hide strt_pts = tensor([[0,0],[2,-1],[1,1]]) end_pts = tensor([[2,-1],[1,1],[0,3]]) diff = end_pts - strt_pts plt.ylim([-3, 3]) plt.xlim([-3, 3]) plt.quiver(strt_pts[:,0], strt_pts[:,1], diff[:,0], diff[:,1], angles=&#39;xy&#39;, scale_units=&#39;xy&#39;, scale=1.) plt.show() . . Matrix Form AX = b . We can see the same view in matrix notation. Same as the row and column view, just in a nice compressed format. . $ begin{bmatrix} 2 &amp; -1 -1 &amp; 2 end{bmatrix}$ $ begin{bmatrix} x y end{bmatrix}$ $=$ $ begin{bmatrix} 0 3 end{bmatrix}$ . Equations, 3 equations 3 unknowns . $2x - y = 0$ . $-x + 2y -z = -1$ . $-3y + 4z = 4$ . Matrix Form . $A=$ $ begin{bmatrix} 2 &amp; -1 &amp; 0 -1 &amp; 2 &amp; -1 0 &amp; -3 &amp; 4 end{bmatrix}$ $b=$ $ begin{bmatrix} 0 -1 4 end{bmatrix}$ . Row Picture . #collapse-hide fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) x, z = tensor(np.linspace(-8,8,100)), tensor(np.linspace(-8,8,100)) X, Z = np.meshgrid(x,z) Y1 = 2*X Y2 = (-1 + X + Z) / 2 Y3 = (4*Z - 4)/3 ax.plot_surface(X,Y1,Z, alpha=0.5, rstride=100, cstride=100) ax.plot_surface(X,Y2,Z, alpha=0.5, rstride=100, cstride=100) ax.plot_surface(X,Y3,Z, alpha=0.5, rstride=100, cstride=100) plt.show() . . Column Picture . We can create the column picture and graph vectors, just like in 2D space. Graphing in 3D is harder to see, but it&#39;s the same concept. . In this example we can clearly see the solution is x = 0, y = 0, z = 1. . $x$ $ begin{bmatrix} 2 -1 0 end{bmatrix}$ $+y$ $ begin{bmatrix} -1 2 -3 end{bmatrix}$ $+z$ $ begin{bmatrix} 0 -1 4 end{bmatrix}$ $=$ $ begin{bmatrix} 0 -1 4 end{bmatrix}$ . #collapse-hide strt_pts = tensor([[0,0,0],[0,0,0],[0,0,0]]) end_pts = tensor([[2,-1,0],[-1,2,-1],[0,-3,4]]) diff = end_pts - strt_pts fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) ax.set_xlim([-5, 5]) ax.set_ylim([-5, 5]) ax.set_zlim([-5, 5]) plt.quiver(strt_pts[0,0], strt_pts[0,1], strt_pts[0,2], end_pts[0,0], end_pts[0,1], end_pts[0,2]) plt.quiver(strt_pts[1,0], strt_pts[1,1], strt_pts[1,2], end_pts[1,0], end_pts[1,1], end_pts[1,2]) plt.quiver(strt_pts[2,0], strt_pts[2,1], strt_pts[2,2], end_pts[2,0], end_pts[2,1], end_pts[2,2]) plt.show() . . Numpy Solver . Here&#39;s how you can solve the equation using Numpy. . a = np.array([[2, -1, 0], [-1, 2, -1], [0, -3, 4]]) b = np.array([0, -1, 4]) x = np.linalg.solve(a, b) print(x) . [ 0. -0. 1.] . Can I solve Ax = b for every b? . Do the linear combinations of the columns fill 3 dimensional space. . If you have some dimensionality in each direction, then you can. 3 equations with 3 unknowns can fill the 3D space as long as they don&#39;t sit on the same line or plane. . # lets expirament length_b = 20 b = np.array([list(np.random.rand(length_b)*10), list(np.random.rand(length_b)*10), list(np.random.rand(length_b)*10)]) for x in range(0,length_b): x = np.linalg.solve(a, b[:,x]) print(x) . [12.34080396 17.25419494 14.45223124] [4.3199813 5.08051595 5.06761607] [11.26347828 12.97487851 12.22512736] [5.70944029 7.59603383 7.26994807] [ 8.14004194 10.62910222 9.74376037] [2.95913308 5.38708946 4.07602836] [ 5.71158581 10.15204127 9.91490065] [ 9.64601458 14.15432693 11.82836017] [14.30704025 20.64995811 17.69860633] [ 7.83852946 14.51438959 12.77361829] [8.10022402 8.2034441 6.89683312] [4.83294145 4.45944243 3.902063 ] [4.97509585 9.38184883 9.47499918] [4.21358292 5.53636436 5.35998439] [ 7.49769118 11.83894164 10.43770683] [11.07197937 17.24535878 15.22695312] [6.41919127 6.39617205 5.86620567] [10.07150973 11.6354783 11.01565376] [10.97611756 12.95884772 10.99723627] [4.40229263 4.48480965 3.50238492] .",
            "url": "https://isaac-flath.github.io/blog/linear%20algebra/2020/05/09/18.06_1_GeometryOfLinearEquations.html",
            "relUrl": "/linear%20algebra/2020/05/09/18.06_1_GeometryOfLinearEquations.html",
            "date": " • May 9, 2020"
        }
        
    
  
    
        ,"post19": {
            "title": "Jupyter Notebook Tutorial",
            "content": "Top 3 uses: . Exploratory analysis, model creation, data science, any kind of coding that require lots of rapid expiramentation and iteration. | Tutorials, guides, and blogs (like this one). Because you have a great mix of text functionality with code, they work really well for tutorials and guides. Rather than having static images, or code snippits that have to get updated each iteration, the code is part of the guide and it really simplifies the process. Notebooks can be exported directly to html and be opened in any browser to give to people. With the easy conversion to html, naturally it&#39;s easy to post them on a web page. | Technical presentations of results. You can have the actual code analysis done, with text explanations. Excess code can be collapsed so that if someone asks really detailed questions you can expand and have every piece of detail. Changes to the analysis are in the presentation so no need to save and put static images in other documents | Cell Types . A cell can be 3 different types. The most useful are code cells and markdown cells. . Code Cells . - Code cells run code The next few cells are examples of code cells - While the most common application is Python, you can set up environments easily to use R, swift, and other languages within jupyter notebooks . Markdown Cells . - This cell is a markdown cell. It is really nice for adding details and text explanations in where a code comment is not enough - They have all the normal markdown functionality, plus more. For example, I can write any technical or mathy stuff using latex, or create html tables in markdown or html. - I can also make markdown tables. . Latex Formulas . $$ begin{bmatrix}w_1&amp;w_2&amp;w_3&amp;w_4&amp;w_5 x_1&amp;x_2&amp;x_3&amp;x_4&amp;x_5 y_1&amp;y_2&amp;y_3&amp;y_4&amp;y_5 z_1&amp;z_2&amp;z_3&amp;z_4&amp;z_5 end{bmatrix}$$ . $ begin{align} frac{dy}{du} &amp;= f&#39;(u) = e^u = e^{ sin(x^2)}, frac{du}{dv} &amp;= g&#39;(v) = cos v = cos(x^2), frac{dv}{dx} &amp;= h&#39;(x) = 2x. end{align}$ . Markdown Table . This is a table for demos . perc | 55% | 22% | 23% | 12% | 53% | . qty | 23 | 19 | 150 | 9 | 92 | . #collapse-hide import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns pd.options.display.max_columns = None pd.options.display.max_rows = None %matplotlib inline . . Running Code . Naturally you can run code cells and print to the Jupyter Notebook . for x in range(0,5): print(x*10) . 0 10 20 30 40 . DataFrames . iris = sns.load_dataset(&#39;iris&#39;) iris[iris.petal_length &gt; 6] . sepal_length sepal_width petal_length petal_width species . 105 | 7.6 | 3.0 | 6.6 | 2.1 | virginica | . 107 | 7.3 | 2.9 | 6.3 | 1.8 | virginica | . 109 | 7.2 | 3.6 | 6.1 | 2.5 | virginica | . 117 | 7.7 | 3.8 | 6.7 | 2.2 | virginica | . 118 | 7.7 | 2.6 | 6.9 | 2.3 | virginica | . 122 | 7.7 | 2.8 | 6.7 | 2.0 | virginica | . 130 | 7.4 | 2.8 | 6.1 | 1.9 | virginica | . 131 | 7.9 | 3.8 | 6.4 | 2.0 | virginica | . 135 | 7.7 | 3.0 | 6.1 | 2.3 | virginica | . Plotting . Below we are going to make a few graphs to get the point accross. Naturally, each graph can be accompanied with a markdown cell that gives context and explains the value of that graph. . Line Chart . # evenly sampled time at 200ms intervals t = np.arange(0., 5., 0.2) # red dashes, blue squares and green triangles plt.plot(t, t, &#39;r--&#39;, t, t**2, &#39;bs&#39;, t, t**3, &#39;g^&#39;) plt.show() . Scatter Plot . Sometimes we will want to display a graph, but may not want all the code and details to be immediately visable. In these examples we can create a scatter plot like below, but collapse the code cell. . This is great when you want to show a graph and explain it, but the details of how the graph was created aren&#39;t that important. . #collapse-hide data = {&#39;a&#39;: np.arange(50), &#39;c&#39;: np.random.randint(0, 50, 50), &#39;d&#39;: np.random.randn(50)} data[&#39;b&#39;] = data[&#39;a&#39;] + 10 * np.random.randn(50) data[&#39;d&#39;] = np.abs(data[&#39;d&#39;]) * 100 plt.scatter(&#39;a&#39;, &#39;b&#39;, c=&#39;c&#39;, s=&#39;d&#39;, data=data) plt.xlabel(&#39;entry a&#39;) plt.ylabel(&#39;entry b&#39;) plt.show() . . Categorical Plot . We can create subplots to have multiple plots show up. This can be especially helpful when showing lots of the same information, or showing how 2 different metrics are related or need to be analyzed together . #collapse-hide names = [&#39;group_a&#39;, &#39;group_b&#39;, &#39;group_c&#39;] values = [1, 10, 100] plt.figure(figsize=(9, 3)) plt.subplot(131) plt.bar(names, values) plt.subplot(132) plt.scatter(names, values) plt.subplot(133) plt.plot(names, values) plt.suptitle(&#39;Categorical Plotting&#39;) plt.show() . . Stack Traces . When you run into an error, by default jupyter notebooks give you whatever the error message is, but also the entire stack trace. . There is a debug functionality, but I find that these stack traces and jupyter cells work even better than a debugger. I can break my code into as many cells as I want and run things interactively. Here&#39;s a few examples of stack traces. . Matrix Multiplication Good . Now we are going to show an example of errors where the stack trace isn&#39;t as simple. Suppose we are trying to multiply 2 arrays together (matrix multiplication). . a = np.array([ [1,2,4], [3,4,5], [5,6,7] ]) b = np.array([ [11,12,14], [31,14,15], [23,32,23] ]) a@b . array([[165, 168, 136], [272, 252, 217], [402, 368, 321]]) . Matrix Multiplication Bad . Now if it errors because the columns from matrix a don&#39;t match the rows from matrix b, we will get an error as matrix multiplication is impossible with those matrices. We see the same idea s the above for loop, stack trace with error and arrow pointing at the line that failed . # here&#39;s another a = np.array([ [1,2,4], [3,4,5], [5,6,7] ]) b = np.array([ [11,12,14], [31,14,15] ]) a@b . ValueError Traceback (most recent call last) &lt;ipython-input-8-52272ca444fc&gt; in &lt;module&gt; 9 [31,14,15] 10 ]) &gt; 11 a@b ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 3) . Second Layer of Bad . But what if the line we call isn&#39;t what fails? What if what I run works, but the function underneath fails? . In these example, you see the entire trace. It starts with are arrow at what you ran that errored. It then shows an arrow that your code called that caused the error, so you can track all the way back to the source. Here&#39;s how it shows a two step stack trace, but it can be as long as needed. . def matmul(a,b): c = a@b return c . matmul(a,b) . ValueError Traceback (most recent call last) &lt;ipython-input-10-7853c1c27063&gt; in &lt;module&gt; -&gt; 1 matmul(a,b) &lt;ipython-input-9-1c8b6b954779&gt; in matmul(a, b) 1 def matmul(a,b): -&gt; 2 c = a@b 3 return c ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 3) . Magic Commands . Magic commands are special commands for Juptyer Notebooks. They give you incredible functionality and you will likley find the experience very frustrating without them. A few that I use often are: . ? | put a question mark or 2 after a function or method to get the documentation. ?? gives more detail than ?. I can also use it to wild card search modules for functions. | shift tab | when you are writing something holding shift + tab will open a mini popup with the documentation for that thing. It may be a funciton, method, or module. | %who or %whos or %who_ls | These are all variants that list the objects and variables. I prefer %whos most of the time | %history | This allows you to look at the last pieces of code that you ran | $$ | wrapping latex code in dollar signs in a markdown cell renders latex code in markdown cells | ! | putting ! at the beginning of a line makes it run that in terminal. For example !ls | grep .csv | %time | I can use this to time the execution of things | . np.*array*? . np.array np.array2string np.array_equal np.array_equiv np.array_repr np.array_split np.array_str np.asanyarray np.asarray np.asarray_chkfinite np.ascontiguousarray np.asfarray np.asfortranarray np.broadcast_arrays np.chararray np.compare_chararrays np.get_array_wrap np.ndarray np.numarray np.recarray . np.array_equal?? . Signature: np.array_equal(a1, a2) Source: @array_function_dispatch(_array_equal_dispatcher) def array_equal(a1, a2): &#34;&#34;&#34; True if two arrays have the same shape and elements, False otherwise. Parameters - a1, a2 : array_like Input arrays. Returns - b : bool Returns True if the arrays are equal. See Also -- allclose: Returns True if two arrays are element-wise equal within a tolerance. array_equiv: Returns True if input arrays are shape consistent and all elements equal. Examples -- &gt;&gt;&gt; np.array_equal([1, 2], [1, 2]) True &gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2])) True &gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3]) False &gt;&gt;&gt; np.array_equal([1, 2], [1, 4]) False &#34;&#34;&#34; try: a1, a2 = asarray(a1), asarray(a2) except Exception: return False if a1.shape != a2.shape: return False return bool(asarray(a1 == a2).all()) File: ~/opt/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py Type: function . a = np.array(np.random.rand(512,512)) b = np.array(np.random.rand(512,512)) %time for i in range(0,20): a@b . CPU times: user 198 ms, sys: 2.68 ms, total: 200 ms Wall time: 34.8 ms . %whos . Variable Type Data/Info a ndarray 512x512: 262144 elems, type `float64`, 2097152 bytes (2.0 Mb) b ndarray 512x512: 262144 elems, type `float64`, 2097152 bytes (2.0 Mb) data dict n=4 i int 19 iris DataFrame sepal_length sepal_&lt;...&gt; 1.8 virginica matmul function &lt;function matmul at 0x1a169cc680&gt; names list n=3 np module &lt;module &#39;numpy&#39; from &#39;/Us&lt;...&gt;kages/numpy/__init__.py&#39;&gt; pd module &lt;module &#39;pandas&#39; from &#39;/U&lt;...&gt;ages/pandas/__init__.py&#39;&gt; plt module &lt;module &#39;matplotlib.pyplo&lt;...&gt;es/matplotlib/pyplot.py&#39;&gt; sns module &lt;module &#39;seaborn&#39; from &#39;/&lt;...&gt;ges/seaborn/__init__.py&#39;&gt; t ndarray 25: 25 elems, type `float64`, 200 bytes values list n=3 x int 4 . %history -l 5 . matmul(a,b) np.*array*? np.array_equal?? a = np.array(np.random.rand(512,512)) b = np.array(np.random.rand(512,512)) %time for i in range(0,20): a@b %whos . Jupyter Extensions . There are many extensions to Jupyter Notebooks. After all a jupyter notebook is just a JSON file, so you can read the JSON in and manipulate and transform things however you want! There are many features, such as variable explorers, auto code timers, and more - but I find I that most are unneccesary. About half the people I talk to don&#39;t use any, and the other half use several. . NBDEV . NBdev is a jupyter extension/python library that allows you to do full development projects in Jupyter Notebooks. There have been books and libraries written entirely in Jupyter notebooks, including testing frameworks and unit testing that goes with them. A common misconception is that Jupyter notebooks cannot be used for that, though many people already have. . . There are many features NBdev adds. Here&#39;s a few. . Using notebooks written like this, nbdev can create and run any of the following with a single command: . Searchable, hyperlinked documentation; any word you surround in backticks will by automatically hyperlinked to the appropriate documentation | Cells in jupyter notebook marked with #export will be exported automatically to a python module | Python modules, following best practices such as automatically defining all (more details) with your exported functions, classes, and variables | Pip installers (uploaded to pypi for you) | Tests (defined directly in your notebooks, and run in parallel). | Navigate and edit your code in a standard text editor or IDE, and export any changes automatically back into your notebooks | . I reccomend checking them out for more detail https://github.com/fastai/nbdev .",
            "url": "https://isaac-flath.github.io/blog/jupyter/2020/05/07/JupyterNotebooks.html",
            "relUrl": "/jupyter/2020/05/07/JupyterNotebooks.html",
            "date": " • May 7, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a Data Scientist with a passion for teaching. . I really enjoy playing with machine learning algorithms so much of my content will probably relate to that in some way :grinning: . Basically anything I find interesting and/or helpful will be included. .",
          "url": "https://isaac-flath.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://isaac-flath.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}